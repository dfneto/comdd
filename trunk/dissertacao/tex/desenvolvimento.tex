\newpage

\chapter{Desenvolvimento}
\label{desenvolvimento}
Este capítulo apresenta a abordagem desenvolvida neste trabalho, cita suas funcionalidades e relata o estudo de caso desenvolvido. Também discute os resultados do estudo de caso, apresenta lições aprendidas durante o estudo de caso e as limitações da abordagem e da implementação. 

\section{O CoMDD - \textit{Collaborative Model Driven Development}}

O CoMDD é uma abordagem que consiste no desenvolvimento colaborativo orientado a modelos, onde a colaboração é referente a edição colaborativa de modelos. Seja mais de uma pessoa editando o mesmo modelo (concorrentemente ou não), seja várias pessoas editando vários modelos, de forma que cada modelo tenha apenas uma pessoa e que esses modelos sejam dependentes.

A figura A ilustra duas pessoas editando um mesmo modelo e a figura B ilustra três pessoas editando diferentes modelos, mas que são dependentes.

A implementação da abordagem CoMDD realizada neste trabalho para evidenciar a hipótese, consiste no uso de uma DSL como abordagem MDD e de uma Wiki para promover a colaboração e suporte da DSL. Mais especificamente, a DSL é para o domínio de robôs móveis autônomos e foi implementada com o ANTLR\footnote{} e a Wiki usada foi a Xwiki\footnote{}. 

A DSL permite a edição de modelos e geração de código-fonte, usando templates, em uma Wiki. Desta forma, a Wiki serve tanto como ferramenta de suporte da DSL quanto ferramenta colaborativa pois possibilita o trabalho em equipe e o versionamento de modelos. 

O implementação do CoMDD permite:
\begin{enumerate}
	\item \textbf{Edição de modelos:} criar ou alterar modelos de acordo com o metamodelo definido\footnote{O metamodelo pode ser alterado na wiki, assim como as transformações, mas a princípio está sendo definido fora da wiki e esta funcionalidade ainda não foi implementada.}. Os modelos serão a entrada do transformador e eles são editados na wiki;
	\item \textbf{Transformação de modelos em código-fonte:} o transformador, desenvolvido para a wiki, gera o código-fonte de acordo com o modelo de entrada;% e apresentar erros de sintaxe\footnote{Na atual versão do CoMDD, o transformador não retorna os erros sintáticos e sim os ignora. O transformador então retorna o código-fonte da parte dos modelos válidas}
	\item \textbf{Colaboração:} a wiki permite que mais desenvolvedores possam editar o mesmo modelo usando uma política \textit{pessimistic};
	\item \textbf{Versionamento de modelos:} a wiki armazena um histórico dos modelos com a possibilidade de comparar as versões e retornar à edições anteriores;
	\item \textbf{Controle de acesso por grupos}: a wiki permite criar um grupo com permissão de edição de modelos e outro com permissão de apenas visualização, por exemplo;
	\item \textbf{Comentários}: há dois tipos de comentários. Um é inserido em cada versão alterada e o outro é inserido na página editada (versão do modelo atual). A figura abaixo ilustra vários comentários na página de edição do modelo (lado esquerdo fig comentarios na pagina de edicao) e comentários específicos para versões (lado direito fig comentarios por Edicao).
\end{enumerate}

No apendice XXX estão detalhes da implementação, como: código-fonte, como fazer o plugin para a xwiki e afins.

A figura XXX ilustra um desenvolvedor editando um modelo (passo 1). Este modelo deve estar de acordo com o metamodelo (passo 2). É o metamodelo que define a estrutura do modelo, ou seja é ele quem define o que é uma bola e se ela vem antes ou depois do quadrado. Se o modelo estiver de acordo, então são aplicadas transformações (passo 3) que geram o código-fonte (passo 4). Todo esse processo é realizado na wiki.

FIGURA!!


%Possíveis de serem implementadas: 
%	Merge (ver como a wikipedia faz e um plugin)
%	Bate papo dentro da wiki
%	Highlight com javascript
%	Wiki como ide: ver outras características de uma ide
%	Metametamodelagem: é possível alterar a propria gramatica, bem como as transformações ainda pela propria wiki, mas isso seria um script
%	Falar da edição de subartefatos: numa wiki é muito simples voce criar uma pagina dentro de outra [[]]

\section{Vantagens}
O CoMDD tem as seguintes vantagens devido ao uso de uma wiki e de MDD:
\begin{enumerate}
	\item \textbf{Produtividade:}
	\item \textbf{DDS:}
	\item \textbf{Comunicação}
	\item \textbf{}
\end{enumerate}

\section{Método}
\label{metodo}
Para tentar evidenciar que a hipótese é possível/verdadeira o CoMDD foi implementado usando o ANTLR\footnote{http://www.antlr.org} e a Xwiki\footnote{http://www.xwiki.org} (ver detalhes de implementação no Apêndice \ref{apendiceE}) e dois estudos de caso foram planejados.

\subsection{Estudo de Caso I: }
O objetivo do primeiro estudo de caso foi avaliar o CoMDD por pessoas não desenvolvedoras. Neste momento como o intuito era avaliar a linguagem e o ambiente do CoMDD e verificar se participantes jovens, com relativa baixa formação, sem conhecimentos de programação e sem conhecimentos do domínio, conseguiriam entender os conceitos e a linguagem. 

\subsubsection{Descrição dos participantes}
Alunos de pré-iniciação científica do Laboratório de Robótica Móvel da Universidade de São Paulo. Três deles tinham 16 anos e um 17 anos, sendo dois garotos e duas garotas. Todos os quatro haviam concluído o segundo colegial.
Já tinham programado para o robô SRV\footnote{vem o site do srv que por algum motivo nao ta compilando no latex!} com o intuito educaional, usando uma API própria e simples usando. Não possuiam conceitos de algoritmos ou de programação orientada a objetos.

\subsubsection{Instruções e Problema Apresentado}
Foi formado duas equipes com dois integrantes cada. Cada equipe ficava em um único computador, ou seja, eram dois computadores com duas pessoas. A distribuição foi definida dessa forma para que fosse estimulada a comunicação e facilitar a resolução do problema. Estima-se que se fosse uma pessoa por computador o experimento iria durar o dobro do tempo, se tornando inviável de conseguir pessoas que se dispusessem em participar.

Antes de passar o comando foi lido junto com os participanetes dois textos, o primeiro explicando o que é o CoMDD (ver \textit{Texto I: O que é o CoMDD?} no apêndice \ref{apendice_textos}) e o segundo texto explicando como usar a DSL criada para o estudo de caso (ver \textit{Texto II: Como programar para o CoMDD} no apêndice \ref{apendice_texto2_como_programar_para_o_comdd}).

Após a leitura, o seguinte comando foi passado:

\begin{center}
 \fbox{
 \parbox{15cm}{
 O código é de um robô que ao receber uma lista de coordenadas deve ser capaz de passar por elas. Seu algoritmo de funcionamento é o seguinte: 
 \vspace{5mm}

 Os sensores devem ler a informação 

 O robô recebe a próxima coordenada 

 O robô processa a informação 

 O robô recebe uma regra a aplicar 

 O robô anda 
 \vspace{5mm}
 
 Esse algoritmo deve ficar sendo executado eternamente, até o robô ser desligado. 

 Agora você deve a partir do algoritmo e das explicações no site ser capaz de escrever um código usando a linguagem do CoMDD. 
 \vspace{5mm}
 
 Requisitos: 

 O robô deve ser da plataforma pionner 

 O robô deve usar os pacotes de localização e o do player 

 O robô deve usar um gps e uma bússola 

 O robô seguir um conjunto de coordenadas 

} } 
\end{center}

O tempo entre o momento que o pesquisador começou a falar com os participantes até o final do experimento foi de aproximadamente 2h45. Este tempo inclui a instrução do pesquisador aos participantes, a resolução do problema e a avaliação feita pelos participantes.

\subsubsection{Resultados}
A resposta correta é a seguinte:

\begin{center}
\fbox{
 \parbox{10cm}{
	plataforma pionner 

	robo david 

	adicionar includes 

	adicionar defines 

	importar pacote player; 

	importar pacote localizacao; 

	criarSensor gps 

	criarSensor bussola 

	\hspace{5mm} int main() \{ 

	\hspace{5mm}\hspace{5mm} gps.ligar();

	\hspace{5mm}\hspace{5mm} bussola.ligar(); 

	\hspace{5mm}\hspace{5mm} carregarListaCoordenadas(); 

	\hspace{5mm}\hspace{5mm} inicializarPlayer(); 

	\hspace{5mm}\hspace{5mm} while(true) \{ 

	\hspace{5mm}\hspace{5mm}\hspace{5mm} bussola.ler(); 

	\hspace{5mm}\hspace{5mm}\hspace{5mm} gps.ler(); 

	\hspace{5mm}\hspace{5mm}\hspace{5mm} receberCoordenada();
 
	\hspace{5mm}\hspace{5mm}\hspace{5mm} processaInfo(); 

	\hspace{5mm}\hspace{5mm}\hspace{5mm} defineRegraSeguirMultiplasCoordenadas(); 

	\hspace{5mm}\hspace{5mm}\hspace{5mm} andar(); 

	\hspace{5mm}\hspace{5mm} \} 

	\hspace{5mm} \} 

}}
\end{center}

\paragraph{Resultados da equipe A}
A equipe A apresentou a seguinte resposta, observando que a identação apresentada é proporcional à original:

\begin{center}
\fbox{
 \parbox{10cm}{
	plataforma pioneer 

	robo MLJ123 

	adicionar defines 

	adicionar includes 

	adicionar while 

	\vspace{5mm}
	importar pacote player; 

	importar pacote localizacao; 

	\vspace{5mm}
	criarSensor gps 

	criarSensor bussola 

	\vspace{5mm}
	int main() \{ 

	\hspace{5mm}       << 

	\hspace{5mm}       gps.ligar(); 

	\hspace{5mm}       bussola.ligar(); 

	\hspace{5mm}       carregarListaCoordenadas(); 

	\hspace{5mm}       inicializarPlayer(); 

	\hspace{1mm} while(true) \{ 

	\hspace{3,5mm}       gps.ler(); 

	\hspace{5mm}	   bussola.ler(); 

	\hspace{5mm}	carregarListaCoordenadas(); 

	\hspace{5mm}	receberCoordenada(); 

	\hspace{5mm}	processaInfo(); 

	\hspace{5mm}	defineRegraSeguirMultiplasCoordenadas(); 

	\hspace{5mm}	andar();             

	\hspace{5mm}        \} 

	\hspace{5mm}        >> 

	\}

}}
\end{center}

\paragraph{Resultado da equipe B}
A equipe B apresentou a seguinte resposta, observando que a identação apresentada é proporcional à original:

\begin{center}
\fbox{
 \parbox{10cm}{
plataforma pioneer 

importar pacote player; 

importar pacote localizacao; 

criarSensor gps 

criarSensor bússola 

carregarListaCoordenadas(); 

int main() { 

<<Inicializações 

Loop 

Funções 

>> 

}	

}}
\end{center}

\paragraph{Observações (trocar esse nome)}
O grupo A teve um apoio de um ajudante local, visto que o experimento foi transmitido a distância, entretanto o grupo A leu uma segunda vez o texto II. O grupo B teve o suporte durante todo o tempo do pesquisador e via skype, enquanto o grupo A teve suporte apenas via instant messanger. O grupo A obteve melhores resultados que o grupo B. Pode-se considerar a resposta apresentada pelo grupo A como correta.

\subsubsection{Opiniões dos participantes}
\textit{Prós:} A linguagem é fácil de entender e o fato de ser em português facilita.

\textit{Contras:} Foi mais complicado entender as intruções do experimento; ficou confusa a função \textit{carregarListaCoordenadas()}.

\subsubsection{Ruídos}

\subsubsection{Conclusões e observações}
\begin{enumerate}
	\item O experimento foi passado a distância, via skype e com a ajuda de um aluno de doutorado do LRM que acompanhou os participantes e auxiliou o grupo A, enquanto o pesquisador auxiliava o grupo B. Não pode-se precisar quanto foi o auxílio que o grupo A recebeu;
	\item Ao observar as equipes estima-se a necessidade de pelo menos duas horas para que eles aprendessem a usar e instalar o Eclipse e SVN;
	\item Os participantes tinham dificuldade ou preguiça de lerem o texto que ensinava como programar para o CoMDD (\ref{apendice_texto2_como_programar_para_o_comdd})
	\item Os grupos, principalmente o grupo B, tinham o hábito de perguntarem constantemente se o que faziam estava certo;
	\item Os participantes copiavam do texto \ref{apendice_texto2_como_programar_para_o_comdd} e colavam na página de edição;
	\item Para pessoas que nunca programaram fica difícil elas entenderem o funcionamento da linguagem. Era esperado que elas compreendessem mais rapidamente.
\end{enumerate}

\subsubsection{Lições aprendidas}
Como aprendizado do estudo de caso I é necessário planejar melhor em dois aspéctos:
\begin{itemize}
	\item Organizar melhor a infra-estrutura: verificar quantos computadores serão necessários, se a comunicação for on-line preparar os softwares necessários e orientar bem uma pessoa que possa ajudar e que esteja presente com os participantes. No caso deste experimento houve um mal planejamento da infra-estrutura e da orientação ao ajudante; 
	\item Para um experimento deste tipo o ideal é evitar ajudar os participantes para se ter uma opinião mais real. No caso deste experimento há quatro hipóteses não excludentes que expliquem a dependência dos participantes com relação ao pesquisador: (i) relativa baixa instrução dos participantes, (ii) ruídos provocados pela distância, (iii) mal planejamento ou instrução por parte do pesquisador e/ou (iv) a disposição do pesquisador para tirar dúvidas.
\end{itemize}

%-----------------------------------
%--------Estudo de Caso-------------
%-----------------------------------
\subsection{Estudo de Caso II}
O objetivo do segundo estudo de caso foi avaliar comparativamente o CoMDD com a abordagem tradicional\footnote{Neste caso a abordagem tradicional escolhida é a IDE Eclipse com o plugin do SVN instalado (Eclipse+SVN)}, entre desenvolvedores e coletar suas opiniões.

\subsubsection{Descrição dos participantes}
Todos os quatro participantes são formados em ciências da computação, atuaram na indústria desenvolvendo sistemas e estão cursando mestrado ou doutorado na Universidade de São Paulo em ciências da computação.

\subsubsection{Instruções e Problema Apresentado}
\label{instrucoes_comuns}
Os quatro integrantes foram dividos em duas equipes: equipe A (usando o CoMDD) e equipe B (usando Eclipse+SVN). Ambos integrantes de cada equipe estavam em locais (mais especificamente cidades) diferentes na hora do experimento. A equipe A realizou o experimento em um dia diferente da equipe B.

Antes de passar o comando todos os grupos receberam as instruções comuns seguidas instruções específicas. As instruções comuns foram:
\begin{enumerate}
\item A equipe A deve ler o \textit{Texto I: O que é o CoMDD?} (ver \ref{apendice_texto1_o_que_e_comdd}) e a equipe B deve ler o \textit{Texto IB: Instalação do Eclipse+SVN e importação da DSL} (ver \ref{apendice+texto1b_instalacao});
\item Ler o \textit{Texto II: Como programar para o CoMDD} (ver \ref{apendice_texto2_como_programar_para_o_comdd});
\item Pode-se comentar na edição do modelo usando "//";
\item A função carregarListaCoordenadas() já está configurada para a lista de coordenadas, desta forma vocês não devem se preocupar em passar um lista de coordenadas, apenas chamar a função;
\item O desenvolvimento é feito em turnos e em cada turno apenas um desenvolvedor pode trabalhar no código (editá-lo), para evitar conflitos e \textit{merges}. Cada turno tem 3 minutos para desenvolver e mais 2 minuto para comentar e comentar no CoMDD (equipe A) ou fazer o \textit{commit} (equipe B). Por ex: 

0'-3': O desenvolvedor 1 começa programando enquanto o desenvolvedor 2 fica esperando (enquanto isso os desenvolvedores podem se comunicar via email ou gtalk);

3'01s - 5': o desenvolvedor 1 tem de salvar suas alterações e comentar o código caso ache necessário;

5'01s - 6': ninguém faz nada para que o servidor atualize os dados;

6'01s-9': o desenvolvedor 2 assume o comando de edição do código e o desenvolvedor 1 fica aguardando ou conversando via e-mail ou gtalk com o desenvolvedor 2 caso este precise;

9'01s-11': o desenvolvedor 2 tem de salvar suas alterações e comentar o código caso ache necessário;

11'01s-14': o ciclo se repete
\end{enumerate}

O seguinte comando foi passado:

\begin{center}
 \fbox{
 \parbox{15cm}{
O código é de um robô que ao receber uma lista de coordenadas deve ser capaz de passar por elas. Seu algoritmo de funcionamento é o seguinte: 
 \vspace{5mm}

 Os sensores devem ler a informação 

 O robô recebe a próxima coordenada 

 O robô processa a informação 

 O robô recebe uma regra a aplicar, de acordo com os requisitos 

 O robô atua no ambiente  
\vspace{5mm}
 
 Esse algoritmo deve ficar sendo executado eternamente, até o robô ser desligado. 

 Agora vocês devem a partir do algoritmo e das explicações no site serem capazes de escrever um código usando a linguagem do CoMDD.  
 \vspace{5mm}
 
 Requisitos: 

 O robô deve ser da plataforma pionner----------------------------------------------------- Dev1 

 O nome do robê deve ser uma concatenação dos nomes dos desenvolvedores------- Dev2 

 O robô deve usar os pacotes de localização------------------------------------------------ Dev1 

 O robô deve usar os pacotes do player------------------------------------------------------ Dev2 

 O robô deve usar um gps---------------------------------------------------------------------- Dev1 

 O robô deve usar uma bússola---------------------------------------------------------------- Dev2 

 O robô seguir um conjunto de coordenadas--------------------------------------- Dev1 + Dev2

} } 
\end{center}

\subsubsection{Equipe A: CoMDD}
Além das instruções comuns apresentadas na seção \ref{instrucoes_comuns}, para equipe A foram apresentadas as seguintes intruções:
\begin{enumerate}
\item Pode-se usar todas as funcionalidades da wiki como comentários, histórico e comparação de versões\footnote{Um exemplo de edição normal (sem ser usando a DSL) foi apresentado para que os participantes pudessem saber como e onde editar, comentar e comparar versões.};
\item Dêem preferencialmente para comunicação que a própria wiki fornece: os comentários, caso contrário usem um instant messanger ou o e-mail e depois fornecer o log para o pesquisador
\end{enumerate}


\subsubsection{Equipe B: Eclipse+SVN}
Além das instruções comuns apresentadas na seção \ref{instrucoes_comuns}, para equipe B foram apresentadas as seguintes intruções:
\begin{enumerate}
\item Pode-se usar todas as funcionalidades do plugin SVN como check-in check-out, comentários, histórico e comparação de versões\footnote{Os participantes já conheciam o plugin.};
\item Dêem preferencialmente para comunicação que o próprio SVN fornece: os comentários, caso contrário usem um instant messanger ou o e-mail e depois fornecer o log para o pesquisador
\item Não usar as funções comuns de uma IDE como highlight, auto-complete e etc\footnote{Assim as equipes ficam mais iguais, uma vez que no CoMDD essas funcionalidades não foram implementadas.}\footnote{O Eclipse tem um ambiente que não usa as funções citadas.}
\end{enumerate}


\subsubsection{Resultados}
A resposta correta é a mesma apresentada na seção...

\subsubsection{Resultados da Equipe A aqui entra mais um sub}
A equipe A apresentou a seguinte resposta:

\begin{center}
\fbox{
 \parbox{15cm}{
//O robô deve ser da plataforma pionner - Danilo

plataforma pionner

\vspace{5mm}
//O nome do robê deve ser uma concatenação dos nomes dos desenvolvedores - Davi

robo davnilo

\vspace{5mm}
//O robô deve usar os pacotes de localização - Danilo

importar pacote localizacao

\vspace{5mm}
//O robô deve usar os pacotes do player - Davi

importar pacote player;

\vspace{5mm}
//O robô deve usar um gps - Danilo

criarSensor gps

\vspace{5mm}
//O robô deve usar uma bússola- Davi

criarSensor bussola

\vspace{5mm}
//função principal do código

int main() \{

bussola.ligar();

gps.ligar();

\vspace{5mm}
//O robô seguir um conjunto de coordenadas - Danilo + Davi

while(true) \{

bussola.ler(); 

gps.ler();

receberCoordenada();

processaInfo();

defineRegraSeguir(); 

defineRegraNaoBater();

andar();

\}

\}

}}
\end{center}

Comunicação do grupo A: colocar o historico da wiki - ver figura 

O tempo entre o momento que o pesquisador começou a falar com os participantes até o fim foi de aproximadamente 1h45. Neste tempo inclui a instrução do pesquisador aos participantes, a resolução do problema e a avaliação feita pelos participantes.

Em um momento eu indiquei que o modelo tinha erros e ainda assim, no final ainda faltou algumas coisas no modelo.

O danilo teve uma duvida e eu sugeri ele ler a api ou perguntar para a dupla dele, mas perguntaram menos do que no estudo de caso 1

Sugeri para eles conversarem entre si e lerem a API

O tempo não era muito rígido, mas apenas uma pessoa editava por vez durante um turno.

O modelo apresentado no final foi o seguinte:

<>

\subsubsection{Resultados da Equipe B aqui entra mais um sub}
A Equipe B apresentou a seguinte resposta:

\begin{center}
\fbox{
 \parbox{15cm}{
// Definindo a plataforma do robo como pioneer

plataforma pioneer

\vspace{5mm}
// Define o nome do robo como uma concatenacao dos nomes dos desenvolvedores

robo filipeAlexandre

\vspace{5mm}
adicionar includes

adicionar defines

\vspace{5mm}
importar pacote localizacao;

importar pacote player;

\vspace{5mm}
criarSensor gps

criarSensor bussola

\vspace{5mm}
int main() \{

\vspace{5mm}
    \hspace{5mm} // Ligar o GPS

    \hspace{5mm} gps.ligar();
    
\vspace{5mm}
    \hspace{5mm} // Ligar Bussola

    \hspace{5mm} bussola.ligar();

\vspace{5mm}    
    \hspace{5mm} // Carrega lista de coordernadas e inicializa Player

    \hspace{5mm} carregarListaCoordenadas();

    \hspace{5mm} inicializarPlayer();

\vspace{5mm}    
    \hspace{5mm} // Define que robo ira seguir um conjungo de coordenadas

    \hspace{5mm} defineRegraSeguirMultiplasCoordenadas();

\vspace{5mm}    
    \hspace{5mm} // Loop

    \hspace{5mm} while(true) \{

        \hspace{5mm}\hspace{5mm} // Le os dados atuais

        \hspace{5mm}\hspace{5mm} gps.ler();

        \hspace{5mm}\hspace{5mm} bussola.ler();

\vspace{5mm}        
        \hspace{5mm}\hspace{5mm} // Processa informacoes

        \hspace{5mm}\hspace{5mm} processaInfo();

        \hspace{5mm}\hspace{5mm} receberCoordenada();


\vspace{5mm}        
        \hspace{5mm}\hspace{5mm} andar();

    \hspace{5mm} \}

\}

}}
\end{center}

Conversa do grupo B: ver figura 

O tempo entre o momento que o pesquisador começou a falar com os participantes até o fim foi de aproximadamente 2h45. Neste tempo inclui a instrução do pesquisador aos participantes, a resolução do problema e a avaliação feita pelos participantes.

O grillo e o michetti perguntou se sempre vai ter que adicionar defines, includes, robo michetti, plataforma pioneer
Eles pensaram que era um requisito por turno, mas esclareci que não.
O tempo foi mais rigido e eles conversaram pouco pelo skype, até que os instruí para que usassem algum instant messanger ao invés de uma voice conference.
Este grupo está usando um instant messagener, coisa que o grupo anterior não usou. Abaixo o log da conversa: ver apendice \ref{apendice_log}

Depois do experimento elas são questionadas (ver questionário) e por fim são apresentadas para a outra abordagem, a que não usaram.



equipe 1...
equipe 2...
O grupo A, que leu pela segunda vez a API teve melhores resultados que o grupo B. 

\subsubsection{Opiniões dos participantes}
\subsubsection{Equipe A} aqui entra mais um sub
A seguir são apresentadas as perguntas feitas aos participantes da Equipe A com suas respectivas respostas:

\textbf{O que vcs acharam da linguagem?}
Danilo: tá legal mas as funcoes estão muito genéricas, includes e defines estao confusos (redundante a parte de adicionar includes e importar pacotes)
Davi: linguagem primitiva, abrir fechar parênteses e chaves, os pacotes já deveriam estar todos inclusos sem a necessidade de importar

\textbf{Vocês mudariam algo na sintaxe?}
Danilo: a estrutura da linguagem é comum a C, Java ao contrario do begin. É melhor deixar tudo em português ou tudo em inglês.
Davi: a sintaxe esta boa para quem consegue programar em C ou java, aí consegue entender, mas para quem nunca programou (), {} e ; não significa nada.

\textbf{Os comentários que vocês escreveram foram úteis de alguma forma?}
Danilo: interessante. Mas no mundo real um chat ou gtalk é mais útil, caso os dois estejam programando na mesma classe. Mas para documentação ou quando os desenvolvedores não estão ao mesmo tempo e na mesma classe, é útil. 
Davi: o sistema de comentário do svn funciona melhor, porque ao dar o commit você é obrigado a comentar e ao dar o check out você é obrigado a ler. Na wiki fica dissociado do código.

\textbf{E o histórico, foi útil?}
Danilo: Não usou. É mais util quando alguém faz alguma cagada.
Davi: não usou

\textbf{De uma maneira geral, o que vocês acharam da abordagem?}
Dan: não é muito interessante uma vez que tenho que esperar pela pessoa terminar programar para depois programar. No tradicional os dois podem programar juntos e depois fazer o merge ou edição simultanea estilo o google seria interessante. \textbf{E se fosse em classes separadas ao memso tempo?} Aí é interessante.
Programar na web também é bom, o lance do histórico tambem.
É bom a flexibilidade de estar em qualquer computador.
Davi: programar na web é bom porque evita problemas de Infraestrutura (a infraestrutura é instantanea, independente do computador).

\textbf{Então seria interessante uma wiki ou seria melhor um outro site?}
Danilo: a wiki um site mais dinamico, mais facil de editar, as pessoas já conhecem.
Davi: poderia ser um site mais especializado

\textbf{O que voce achou da abordagem comdd e da abordagem eclipse+svn? Que comparação vocês fazem entre o eclipse+svn e o CoMDD? Qual vocês preferem?}
Danilo: estar na web é mais flexivel, configurar uma ide, svn e tudo o mais é trabalhoso
Davi: em geral é melhor programar na wiki do que usar uma ide, mas fica dependente da conexão. Aí seria interessante ter uma forma de usar a wiki mesmo seminternet.

\textbf{Vocês usariam uma wiki no lugar do eclipse+svn? Por que não? E se fosse para fazer programas como este, vocês usariam o CoMDD?} 
Danilo: usaria desde que o processo de compilação funcionasse, agora sem compilar e sem executar não.
Davi: concordo.



\subsubsection{Equipe B} aqui entra mais um sub
A seguir são apresentadas as perguntas feitas aos participantes da Equipe A com suas respectivas respostas:

\textbf{A empresa de voces seguia essa abordagem?}
Usam o eclipse e o subversion

\textbf{O que vcs acharam da linguagem?}
Michetti: fácil e simples, poucos comandos
Grillo: curva de aprendizagem rapida, mas faltou pratica, não sei se o codigo funciona, a sintaxe é simples
outra coisa seria melhorar a documentação para incluir qual o simbolo que indica comentário, e quando se deve usar ou não ponto e virgula

\textbf{Vocês mudariam algo na sintaxe?}
Grillo e Michetti: a parte dos includes poderia ser uma linha só já que sempre vai precisar dela poderia ser numa linha.

\textbf{Como voces colaboraram? O que foi mais importante, os comentarios?}
Eles: O comentário do log não usaram porque o codigo é pequeno e usaram apenas os comentarios no codigo. Michetti: o comentário do svn é mais quando tem algum problema e não para notificar o que foi feito.

\textbf{Os comentários que vocês escreveram no svn foram úteis de alguma forma?}
Não usaram

\textbf{E o histórico, foi útil?}
Não usaram

\textbf{E quais funcoes do SVN voces acham importantes alem das que voces usaram?}
Michetti: Histórico caso tenha algum problema, merge caso editassem ao mesmo tempo.
Grillo: quando o codigo é muito extenso é importante comparar as versoes de código para ver o que tá sendo alterado (as versoes do repositorio, com a local, o que alterou...)

\textbf{Voces acham que a wiki atenderia esses propositos que o svn+eclipse trás?}
M: para editar código eu nunca pensei numa wiki para isso, usaria mais para colaboração na documentação.
G: auxilio de sintaxe no eclipse, auto-complet, import automatico, clicar em um arquivo e ir para outro arquivo. A parte de comentário, versionar, alterar o texto é praticamente a mesma coisa. Não sei se caso editasse ao mesmo tempo não sei como se comportaria.

\textbf{O que voce achou da abordagem comdd e da abordagem eclipse+svn? Que comparação vocês fazem entre o eclipse+svn e o CoMDD? Qual vocês preferem?}
M: to acostumado com o eclipse+svn, mas uso tambem o controle de versao integrado com um bugtrack.
G: cor da grama, muita coisa já tem pronta pro eclipse, costume principal barreira, pensando como programador ainda usaria o eclipse.
Tá, mas pensando que usariamos uma dsl e não java, logo seria algo bem mais simples.

\textbf{Seria bom todos esses programas para matar uma formiga?}
Para um projeto pontual e pequeno o comdd supriria mas para algo maior e complexo.



\subsubsection{Ruídos e mal planejamento}

\subsubsection{Conclusões e observações}
Quanto a colaboração do grupo A: Foram instruídos a usarem os comentarios da wiki e puderam comentar no modelo usand

Quanto ao uso do svn o grupo B: usou Check in, check out, update, não merge ou comparar codigo

no experimento acho que as pessoas colaboraram igualmente, dando ainda um ponto positivo para o svn que "obriga" a pessoa a comentar, contudo fica muito mais facil da pessoas ler um comentário na wiki, só que com uma wiki é muito mais facil e simples de qualquer pessoa colaborar, bastando para isso ter permissões.

Para atender um determinado dominio, a wiki é o suficiente, para coisas simples, para algo mais complexo e que necessite de varias pessoas editando ao mesmo tempo e que podem dar erro, ai talvez o melhor seja a tradicional.

\subsubsection{Lições aprendidas}
Como aprendizado do estudo de caso II ...











Será pedido para duas equipes diferentes a mesma tarefa, sendo que uma delas usara o eclipse+svn e a outra uma wiki apenas. Ambas usarão dsls e geração de código, mas nao terao os recursos tradicionais de uma ide como import, highlight sugestao ... 

Para isso será implementado a dsl no eclipse e numa wiki usando o xtext/xpand e o antlr respectivamente. 


\subsection{Estuo de caso 3: análise de vídeos e planilha de ticar}
BLAHBLHABLHA...

\section{Limitações e Soluções}
Deficiencia do CoMDD: nao compila, entao subentende-se que o codigo que ela gera esta sintaticamente correto, mas ela pode retornar erros 

como integrar testes? debug? ou seria isso inexistentes em dsls ja que elas nao tem um compilador?
\subsection{Do trabalho}
Escopo do trabalho: avaliar em que casos pode-se usar uma wiki no lugar de um svn nao faz parte do escopo deste trabalho 

A abordagem pessimistica possui suas desvantagens como "In contrast, the pessimistic policy has some disadvantages. First, locks can cause an unnecessary serialization over the development process. Sometimes different developers can independently modify different parts of the same CI, but using a lock-based approach that is not possible. In addition, locks can cause a false sense of security (Collins-Sussman et al., 2004). Developers may think that their work will not be affected by the work of other developers due to the
locks. However, sometimes CIs rely on other CIs that can be modified by other developers. This situation leads to indirect conflicts (Sarma et al., 2003). \cite{Prudencio2012} Assim, um trabalho futuro seria no estudo de estratégias otimísticas ou até mesmo na adoção de ambas como propõe o trabalho de Prudencio et al. \cite{Prudencio2012}.

\subsection{Da ferramenta}
Desvantagem da linguagem apontada por mim: o código gerado não pode ser testado uma vez que precisa usar o robô, mas o mais importante é ver como as pessoas interagem e colaboram.


\subsection{Do estudo de caso}

\section{Contribuições do CoMDD}
MDD e tudo na web: mais produtividade 
Modelos e wiki: aproximação maior de todos os envolvidos no processo, e com isso softwares mais próximos dos que o cliente precisa.









O Danilo perguntou se podia usar comentários. Embora a linguagem não dê suporte a isso eu deixei.
Seria interessante a linguagem aceitar código C, C++ ou Java puro.





