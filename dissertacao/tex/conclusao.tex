\newpage

\chapter{Conclusão}
\label{conclusao}

\section{Conclusões - verificar com carinho}
\label{}
"O problema descrito na sessão x foi resolvido como demonstrado nas sessões w e z, em que foi desenvolvido uma abordagem para tratar as situações mencionadas."
concluir a hipotese da seguinte forma, mais ou menos:

O CoMDD é uma abordagem que prega o MDD colaborativo. No caso foi usado uma wiki, mas poderia ser qualquer plataforma web de simples uso e que promovesse velocidade e colaboração. Com as atuais tecnologias a wiki é a que melhor se encaixa nesse perfil. 

Para o problema apresentado o CoMDD mostrou ser capaz de atingir os mesmo resultados que o Eclipse+SVN.

As wikis precisam evoluir mais para que possam, de fato, serem usadas como ferramentas de desenvolvimento e não se limitarem à documentação e afins.

Este trabalho está longe de criar um ambiente de desenvolvimento tão robusto e avançado quanto hoje são as IDES, os SVNs, os \textit{Bug Trackers} e etc. Até porque essas ferramentas já atingiram um grau de maturidade que as torna usáveis para produção. Este trabalho objetivou sim: mostrar que o alinhamente de duas tecnologias aparentemente não interligáveis é possível e benéfico, além de motivar novos estudos na área. 

Os estudos de caso serviram para evidenciar que é possível ter uma abordagem que integre o MDD à uma Wiki e serviram também para mostrar que o CoMDD é aceitado como um possível substituto de abordagens tradicionais desde que traga algumas funcionalidades das IDEs.

O uso do CoMDD é mais fácil que o uso do Eclipse+SVN por não desenvolvedores. Portanto, pode ser interessante adotar o CoMDD quando não desenvolvedores tiverem que participar do desenvolvimento.

O CoMDD exige menos conhecimentos para colaborar do que são exigidos em um sistema de versionamento e ainda o tempo necessário para comentar algo é menor.
%É interessante para projetos menores, que tem a interedependencia entre suas classes nao muito grande, com poucas classes e que estas dependem pouco entre si, mas que necessitam fortemente da colaboração de várias pessoas, e se torna mais interessante quando essa pessoas nao sao desenvolvedoras. 

O MDD agrega um ganho de produtividade no desenvolvimento de software e ... ; modelos possibilitam mais comunicação principalmente por nao especialistas; as wikis incentivam a colaboração devido sua simplicidade de edição e tornam o processo de colaborar/editar mais ágil. Portanto, conclui-se que com o CoMDD pode-se ter ganhos de produtividade e maior colaboração entre desenvolvedores e não desenvolvedores. Entretanto, esta conclusão não foi evidenciada pelos estudos de caso e sim pelo método dedutivo. As premissas são os benefícios do MDD e os benefícios da Wiki. A conclusão é de que o CoMDD herda os benefícios do MDD e da Wiki. 

\section{Contribuições}
\label{}
A principal contribuição deste trabalho é evidenciar que o uso de MDD associado a uma wiki é possível para resolver problemas da mesma forma que é possível usando uma IDE e um sistema de versionamento. E que usando essa abordagem a equipe pode ter ganhos de produtividade e intensificar a colaboração da equipe, principalmente por não desenvolvedores.

O CoMDD permite a edição de modelos, geração de código-fonte e a colaboração entre desenvolvedores e interessados sem a necessidade de ferramentas/ambientes individuais instalados nas estações de trabalho.

Por fim, este trabalho incentiva o uso de aplicações Web ao invés de aplicações locais, permitindo que uma pessoa possa trabalhar de qualquer computador.

Quando não é necessário ferramentas locais para se criar ou editar modelos, ganha-se em termos de velocidade e colaboração, pois menor tempo é necessário para uma pessoa começar a contribuir. Quando se facilita o processo de desenvolvimento/colaboração com o uso de uma wiki no lugar de uma IDE/sistema de versionamento, mais pessoas podem colaborar. Com o uso de modelos no lugar de linguagens de programação de alto nível, mais fácil torna-se o entedimento de não desenvolvedores e consequentemente mai eles podem participar.

%É só pensar no contrario para ver que é verdadeiro, pois se o desenvolvedor precisar do dobro de tempo para instalar um svn/ide e os mesmos forem 3 vezes mais dificeis de serem usados temos com isso menos pessoas nao desenvolvedoras participando. Talvez para o desenvolvedor nao importe o quanto seja dificil usar um svn e o quanto isso va demandar tempo no desenvovlimento de software ( na realidade isso importa pq vai atingir diretamente na produtividade), mas para o nao desenvolvedor isso importa muito -> posso colocar uma pergunta assim no questionario dos videos.

>>O CoMDD ainda poder muito útil para ensinar programação uma vez que nao é necessário programas locais e o próprio CoMDD pode compilar/simular, mas para isso a ferramenta precisa ser melhor integrada.
>>Uma biblioteca de componentes em alto nível com a capacidade de geração de código.

>>sincronismo entre modelos e documentação

MDD e tudo na web: mais produtividade //
Modelos e wiki: aproximação maior de todos os envolvidos no processo, e com isso softwares mais próximos dos que o cliente precisa.


\section{Trabalhos Futuros}
\label{}
Algumas perguntas não foram levantadas no decorrer deste trabalho e espera respondê-las em trabalhos futuros. São elas:

\begin{enumerate}
 \item Pode-se dizer que a Wiki comportou-se bem com o MDD, contudo como ela se comportaria com uma abordagem tradicional orientada a código? Ou seja, como seria programar em Java, por exemplo, em uma wiki? E será que um código-fonte seria tão colaborativo quanto um modelo?

 \item As equipes do segundo estudo de caso foram de dois integrantes apenas, como o CoMDD se comportaria com equipes maiores e com mais pessoas compartilhando o mesmo artefato?

 \item O código-gerado pelo modelo foi validado por um especialista do domínio que ajudou e acompanhou a criação da DSL usada no CoMDD, contudo, como validar os modelos ao invés do código-fonte, de forma que garanta que o código-fonte gerado está correto e de forma que permita o retorno de erros aos desenvolvedores? -- Acho que essa é uma questão mais de implementação.

 \item Nesta abordagem as transformações e o metamodelo foram definidos fora da wiki, entretanto poderiam ser definidos pela própria wiki. Quais benefícios a edição colaborativa das transformações e dos metamodelos traria no desenvolvimento de software?

 \item A abordagem do CoMDD implementada e avaliada contou com o desenvolvimento colaborativo seguindo uma abordagem \textit{pessimistic}, contudo como a abordagem compartaria-se caso tivesse outras formas de colaboração como: i. Edição concorrente e merge de modelos (adotando a abordagem \textit{otimistic}; ii. Edição em tempo real estilo google docs; iii. Edição de outros artefatos que fossem dependentes\footnote{Pode-se criar facilmente links de uma página para outra na wiki}.

 \item Como seria o nível de aceitação caso o CoMDD tivesse funcionalidades mais próximas de uma IDE, como: \textit{highligth}, auto-complet e link entre palavras, de forma que ao clicar em um método é apresentado a definição dele, por exemplo?

\item O estudo de caso II mostrou-se bem sucessido, entretanto para que outros casos o CoMDD pode ser útil? 
 
\end{enumerate}

\section{Limitações do Trabalho}

O CoMDD pode ser útil no desenvolvimento de algoritmos, contudo isso não foi testado.

O ideal seria agregar funcionalidades de uma IDE às wikis, permitir o desenvolvimento simultâneo e a edição em tempo real que hoje tem o google docs. Dessa forma o CoMDD teria mais chances de vigorar na comunidade de desenvolvedores.
% Mas a ideia de que quando voce edita um arquivo esta editando diretamente no servidor e portanto a cópia final simplifica (talvez agiliza tbm) o trabalho evitando conflitos de mege (afirmação forte). As wikis nunca foram pensadas para esse fim e por isso podem melhorar para este propósito. 

Em relação ao domínio, espera-se que para qualquer domínio o CoMDD possa ser interessante, mas este trabalho não evidenciou isso.

O CoMDD não apresentava erros de sintaxe, o que deixava os desenvolvedores do estudo de caso II relativamente desorientados.

A abordagem pessimistica possui suas desvantagens como "In contrast, the pessimistic policy has some disadvantages. First, locks can cause an unnecessary serialization over the development process. Sometimes different developers can independently modify different parts of the same CI, but using a lock-based approach that is not possible. In addition, locks can cause a false sense of security (Collins-Sussman et al., 2004). Developers may think that their work will not be affected by the work of other developers due to the
locks. However, sometimes CIs rely on other CIs that can be modified by other developers. This situation leads to indirect conflicts (Sarma et al., 2003). \cite{Prudencio2012} Assim, um trabalho futuro seria no estudo de estratégias otimísticas ou até mesmo na adoção de ambas como propõe o trabalho de Prudencio et al. \cite{Prudencio2012}.

A DSL foi projetada para que fosse simples de forma que pessoas pudessem compreendê-la facilmente. Do contrário seria mais difícil realizar um estudo de caso. Entretanto, entende-se que uma DSL mais robusta e que atendesse mais casos estaria mais próxima da realidade. %Podia ter me preocupado em fazer uma dsl mais complexa para que mais pessoas pudessem trabalharem juntas, ou seja, necessitasse mais do trabalho colaborativo. Contudo mais difícil fica de realizar um experimento

Em relação ao domínio escolhido: o código gerado não podia ser testado uma vez que precisava ser inserido no robô, assim se o desenvolvedor pudesse simular o código gerado seria uma informação de retorno importante. Ainda, o cerne do domínio de robótica móvel autônoma são os algoritmos que tornam os robôs autônomos, entretanto a colaboração foi mais na definição dos sensores e atuadores que estes robôs usam, portanto a abordagem seria mais interessante para desenvolverem um algoritmo, só que para isso seria melhor uma edição concorrente estilo google docs. Assim, entende-se que o domínio escolhido foi beneficiado pelo uso de uma DSL, mas não pelo uso da colaboração.



\section{Lições aprendidas}
Uma sugestão é pensar bem no experimento antes de implementar. Acredita-se que teríamos implementado menos e teríamos sido mais diretos até mesmo nos estudos de caso se já soubéssemos exatamente o que estávamos avaliando e que resultados gostaríamos de alcançar.

Pesquisa orientada à teste. Assim como existe desenvolvimento de software orientado a teste onde voce primeiro pensa que testes vai fazer, é mto importante voce pensar em como vai provar sua proposta/hipótese. Uma vez uma mulher no WTD do SBSC me falou isso: como vc vai provar? Na época nao dei mta importancia, mas hoje vejo que é a primeira questao logo depois da hipótese. Aí fica mais facil ate em saber o que vai implementar. Pode ir mais direto! É sempre cruscial ter a visão do todo antes de fazer as partes. Ia fazendo as partes achando que no futuro tudo ia se encaixar. Bom, se encaixou, mas poderia ter sido mais rapido se fosse mais direto e soubesse de tudo antes... Assim foi no estagio da alemanha. Ficava pensando: mas como isso que eu vou fazer se encaixa no projeto maior que o daniel tá?! Pensei que depois ia se integrar e que de alguma forma aquilo que tava fazendo ia ter alguma utilidade, mas vi que nem ele sabia como se integrava as coisas. Nem ele tinha a visão geral. Essa é a diferença do cara que vai ser sempre um desenvolvedor e de um gerente de projeto/orientador. Este último tem a visão do todo. E o bom orientador/gerente, além da visão do todo, sabe mto bem do específico, das partes.



Mostre seu trabalho pra todo mundo! Durante o mestrado, na concepção das ideias! Aí as pessoas vao fazer perguntas que te farao pensar. Foi assim que conversando com o artur pensei em algo que nem o lucredio tinha pensado antes! E saiba explicar por mais complexo que seja o que vc faz para qualquer pessoa! É sua tarefa saber simplificar e nao do ouvinte saber entender conceitos complexos. O Artur e outros já diziam: se algo está complexo de mais é pq ta fazendo errado. Quebre em partes menores então! Essa é a filosofia linux: quebre em pedaços tao pequenos a ponto de serem simples de fazer, nao importa o quanto dificil e complexo o problema seja no começo.

o proprio rafael e o danilo me deram boas dicas mas ja era no final do trabalho :P

e sempre faça questionarios com perguntas que vc quer responder no seu trabalho. o lance do exp 3 que to fazendo parece ser mto bom!

cuidado com o que vc lê. Há muito lixo e artigos publicados que nao tem referencias ou dao ideias sem fundamento.... estao em ingles e "bons congressos"
