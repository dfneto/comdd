% This file was created with JabRef 2.5.
% Encoding: UTF8

@INPROCEEDINGS{Bendix2001,
  author = {Lars Bendix and Otto Vinter},
  title = {Configuration Management from a Developer’s Perspective},
  booktitle = {in Proceedings of the EuroSTAR 2001 Conference},
  year = {2001},
  pages = {19-23},
  address = {Stockholm, Sweden},
  month = {November},
  abstract = {With the advent of the web and the ever-increasing need for more rapid
	application development, the role of Configuration Management has
	changed from primarily a QA function, to a critical part of a development
	team's daily operation.
	
	
	This intensive full day tutorial will give you a new perspective on
	Configuration Management. We concentrate on how CM supports your
	team in its daily development process. We will teach you the principles
	of team based CM through a set of metaphors. Through group exercises
	you will be able to outline a CM plan for your team. You will also
	learn how to introduce these CM principles to your team in a workshop
	format, enabling them to see the benefits of CM from their perspective,
	rather than as some bureaucratic process invented by the QA department.
	From our experience this is an effective way to introduce CM to a
	development team and thus change their attitude towards CM.},
  crossref = {Bendix2009},
  file = {:C\:\\Documents and Settings\\david\\Meus documentos\\My Dropbox\\PROJETO DE MESTRADO\\Artigos\\Configuration Management from a Developer’s Perspective - Bendix2001.pdf:PDF},
  owner = {david},
  situation = {Stand by},
  theme = {SCM},
  timestamp = {2010.01.22},
  url = {http://www.cs.lth.se/home/Lars_Bendix/Publications/BV01/paper10.pdf}
}

@INPROCEEDINGS{Kogel2008,
  author = {K\"{o}gel, Maximilian},
  title = {Towards software configuration management for unified models},
  booktitle = {CVSM '08: Proceedings of the 2008 international workshop on Comparison
	and versioning of software models},
  year = {2008},
  pages = {19--24},
  address = {New York, NY, USA},
  publisher = {ACM},
  abstract = {Change occurs throughout the software lifecycle. Software Configuration
	Management tools and techniques provide the foundation to effectively
	control change. With a growing number of approaches combining models
	from different domains into one unified, integrated model, ([15],
	[12]), there is also an emerging demand for SCM techniques and methods
	that are able to support these unified models. Traditional SCM systems
	operating on the abstraction of a filesystem and managing change
	at the granularity of textual lines are not adequate for these requirements.
	We propose a novel approach to SCM for unified models combining product
	versioning, operation-based deltas and change packages. To demonstrate
	feasibility we have implemented our approach in Sysiphus a suite
	of tools for collaborating over Software Engineering artifacts represented
	in a unified model.},
  crossref = {Bendix2009},
  doi = {http://doi.acm.org/10.1145/1370152.1370158},
  file = {:C\:\\Documents and Settings\\david\\Meus documentos\\My Dropbox\\PROJETO DE MESTRADO\\Artigos\\Towards Software Configuration Management for Unified Models - Kogel2008.pdf:PDF},
  isbn = {978-1-60558-045-6},
  keywords = {configuration management, operation-based, scm, unified model, versioning},
  location = {Leipzig, Germany},
  situation = {Stand by},
  theme = {SCM},
  timestamp = {2010.01.22}
}

@INPROCEEDINGS{Kelter2005,
  author = {Udo Kelter and Jürgen Wehren and Jörg Niere},
  title = {A Generic Difference Algorithm for UML Models.},
  booktitle = {Software Engineering},
  year = {2005},
  editor = {Peter Liggesmeyer and Klaus Pohl and Michael Goedicke},
  volume = {64},
  series = {LNI},
  pages = {105-116},
  publisher = {GI},
  biburl = {http://www.bibsonomy.org/bibtex/2aac4c7e5e8448a26c515831445975813/dblp},
  crossref = {Selonen2007},
  date = {2007-06-04},
  description = {dblp},
  isbn = {3-88579-393-8},
  keywords = {dblp},
  problem/context = {Não vi nada},
  theme = {Comparação de Modelos},
  timestamp = {2010.02.17},
  url = {http://dblp.uni-trier.de/db/conf/se/se2005.html#KellerWN05}
}

@INPROCEEDINGS{Murta2008,
  author = {Murta, Leonardo and Corr\^{e}a, Chessman and Prud\^{e}ncio, Jo\,
	{a}o Gustavo and Werner, Cl\'{a}udia},
  title = {Towards odyssey-VCS 2: improvements over a UML-based version control
	system},
  booktitle = {CVSM '08: Proceedings of the 2008 international workshop on Comparison
	and versioning of software models},
  year = {2008},
  pages = {25--30},
  address = {New York, NY, USA},
  publisher = {ACM},
  abstract = {Models are becoming first class artifacts in Software Engineering.
	Due to that, an infrastructure is needed to support model evolution
	in the same way we have for source-code. One of the key elements
	of such infrastructure is a version control system properly designed
	for models. In previous work, we presented Odyssey-VCS, a version
	control system tailored to fine-grained UML model elements. In this
	paper, we discuss the main improvements that we are incorporating
	on the second release of this system, which are: support for UML
	2, reflective processing, explicit branching and auto-branching,
	generic merge algorithm, support for pessimistic concurrency policy,
	and support for hooks.},
  crossref = {Bendix2009},
  doi = {http://doi.acm.org/10.1145/1370152.1370159},
  file = {:home/david/Dropbox/PROJETO DE MESTRADO/Artigos/Towards Odyssey-VCS 2 - Improvements over a UML-based Version Control System - Murta2008.pdf:PDF;:C\:\\Documents and Settings\\david\\Meus documentos\\My Dropbox\\PROJETO DE MESTRADO\\Artigos\\Towards Odyssey-VCS 2 - Improvements over a UML-based Version Control System - Murta2008.pdf:PDF},
  isbn = {978-1-60558-045-6},
  keywords = {unified modeling language (UML), version control},
  location = {Leipzig, Germany},
  situation = {Stand by},
  theme = {Versionamento},
  timestamp = {2010.01.22}
}

@ARTICLE{Ohst2003,
  author = {Ohst, Dirk and Welle, Michael and Kelter, Udo},
  title = {Differences between versions of UML diagrams},
  journal = {SIGSOFT Softw. Eng. Notes},
  year = {2003},
  volume = {28},
  pages = {227--236},
  number = {5},
  address = {New York, NY, USA},
  crossref = {Selonen2007},
  doi = {http://doi.acm.org/10.1145/949952.940102},
  issn = {0163-5948},
  publisher = {ACM},
  timestamp = {2010.02.17}
}

@INPROCEEDINGS{Selonen2007,
  author = {Petri Selonen},
  title = {A Review of UML Model Comparison Approaches},
  booktitle = {in Proceedings of Nordic Workshop on Model Driven Engineering},
  year = {2007},
  pages = {37-51},
  address = {Ronneby, Sweden},
  abstract = {Several approaches for comparing UML models have emerged in the academia.
	They vary in detail like the way they identify corresponding model
	elements, subset of UML they support, input and output formats they
	support, and assumptions they make about the models. These approaches
	mainly focus on detecting and reporting differences between models,
	typically consecutive versions of UML class diagrams. This review
	paper presents a synthesis of the key characteristics of currently
	available UML-based model comparison approaches and compares their
	commonalities and differences. In addition, it discusses some of
	their potential usage scenarios and puts forward a call for their
	more systematic evaluation.},
  crossref = {Bendix2009},
  file = {:home/david/Dropbox/PROJETO DE MESTRADO/Artigos/A Review of UML Model Comparison Approaches - Selonen2009.pdf:PDF},
  keywords = {UML, model comparison, model differencing, model merging, correspondence},
  owner = {david},
  problem/context = {Foca na comparação de modelos e não no merge},
  review = {Software engineering is an iterative and collaborative process, producing
	series of related models describing the designed system from different
	viewpoints, at different levels of abstraction, or at different phases
	of evolution. Reasoning about the
	
	commonalities and differences among models is a fundamental activity
	to promote understanding of the system as a whole. As the number
	and size of models grow, maintaining a clear picture of the system
	becomes hard without proper tool support.
	
	
	
	In order to support cooperative team work a version management system
	which supports UML models is absolutely necessary, as is the ability
	to calculate differences, present them to developer and provide merge
	operations to come to a consistent model.
	
	
	
	In addition, Model Driven Development is another paradigm that can
	benefit from model integration. With support for composability and
	model integration, the model comparison tools can be seen as an important
	operation for supporting Model Driven Development for merging together
	the results of different transformations. Merge is a fundamental
	operation for building a modeling framework supporting chains of
	model manipulation operations.},
  situation = {OK},
  theme = {Comparação},
  timestamp = {2010.01.21}
}

@INPROCEEDINGS{Selonen2007a,
  author = {Selonen, Petri and Kettunen, Markus},
  title = {Metamodel-Based Inference of Inter-Model Correspondence},
  booktitle = {CSMR '07: Proceedings of the 11th European Conference on Software
	Maintenance and Reengineering},
  year = {2007},
  pages = {71--80},
  address = {Washington, DC, USA},
  publisher = {IEEE Computer Society},
  crossref = {Selonen2007},
  doi = {http://dx.doi.org/10.1109/CSMR.2007.31},
  isbn = {0-7695-2802-3},
  timestamp = {2010.02.17}
}

@INPROCEEDINGS{Whitehead2007,
  author = {Whitehead, Jim},
  title = {Collaboration in Software Engineering: A Roadmap},
  booktitle = {FOSE '07: 2007 Future of Software Engineering},
  year = {2007},
  pages = {214--225},
  address = {Washington, DC, USA},
  publisher = {IEEE Computer Society},
  crossref = {Lanubile2009},
  doi = {http://dx.doi.org/10.1109/FOSE.2007.4},
  isbn = {0-7695-2829-5},
  relevance = {5},
  review = {Seria muito bom eu ler esse artigo},
  theme = {Colaboração},
  timestamp = {2010.02.10}
}

@PROCEEDINGS{NW-MODE2007,
  title = {5th Nordic Workshop on Model Driven Software Engineering (NW-MODE'07)},
  year = {2007},
  address = {Ronneby, Sweden},
  month = {August},
  abstract = {Preface
	
	Modeling is an integral part of engineering disciplines and software
	engineering is not an exception. Models are built to both specify
	details for construction of software systems and to document software
	designs. The models are constructed using various methods and tools,
	such as the popular Unified Modeling Language, or emerging Domain
	Specific Modeling Languages. Modeling is intended to shrink the gap
	between the problem domain and the solution space by raising the
	levels of
	
	abstraction in software development and increasing the degree of automation.
	These, consequently, require new ways of developing the software,
	influencing such activities as requirements engineering, designing,
	testing, or running projects.
	
	Nordic Workshop on Model Driven Engineering – NWMODE – aims to continue
	the traditions of the past series of Nordic workshops on UML (NWUML)
	held throughout the Nordic region. The intention of the workshop
	has always been to bring
	
	together researchers and practitioners working with modeling. The
	workshop topics include the emerging trends in modeling as well as
	empirical experiences of the existing methods.
	
	This year’s edition of the workshop contains a series of papers on
	the topics related to Software Product Lines, Domain Specific Modeling,
	model comparison techniques, or modeling of Service Oriented Architectures.
	It also contains two dedicated
	
	discussion sessions on the topics of quality in modeling and model
	comparison. The dedicated discussion sessions are intended to initiate
	discussions on the topics and hopefully originate collaboration between
	the participants.
	
	As organizers of NWMODE 2007 we would like to thank all the contributors,
	authors and reviewers.
	
	On behalf of the organizers
	
	Miroslaw Staron
	
	Program Chair},
  crossref = {Bendix2009},
  file = {:C\:\\Documents and Settings\\david\\Meus documentos\\My Dropbox\\PROJETO DE MESTRADO\\Artigos\\Nordic Workshop on Model Driven Engineering 2007.pdf:PDF},
  owner = {david},
  situation = {Stand by},
  theme = {Modelagem, UML e MDE},
  timestamp = {2010.01.22}
}

@PROCEEDINGS{NWUML2005,
  title = {NWUML'2005: The 3rd Nordic Workshop on UML and Software Modeling},
  year = {2005},
  abstract = {Preface
	
	Welcome to NWUML’2005: The 3rd Nordic Workshop on UML and Software
	Modeling, which is held in Tampere, Finland, on 29.-31.8.2005. 
	
	The intention of NWUML is to bring together researchers and Ph.D.
	students in the fields of software modeling, including model-based
	development methods and tools in general and UML-based modeling in
	particular. NWUML intends to be an open forum with ample time set
	aside for panels and discussions. The workshop intends to function
	as a platform for establishing co-operative research projects between
	the participants in the region.
	
	Even though there are other events on this area worldwide, we in particular
	hope that a Nordic research community is formed and strengthened.
	The actual workshop program is designed to be such that it leaves
	place for discussions and thereby
	
	hopefully supports future co-operation between participants of the
	workshop.
	
	The past workshops in this series were organized in Ronneby, Sweden
	(2003) and Turku, Finland (2004).
	
	We hope for an interesting and fruitful workshop.
	
	Editors
	
	Tampere , August 2005},
  crossref = {Bendix2009},
  file = {:C\:\\Documents and Settings\\david\\Meus documentos\\My Dropbox\\PROJETO DE MESTRADO\\Artigos\\Nordic Workshop on UML and Software Modeling 2005.pdf:PDF},
  owner = {david},
  situation = {Stand by},
  theme = {UML, modelagem},
  timestamp = {2010.01.22}
}

@INPROCEEDINGS{Abeti2009,
  author = {Abeti, L. and Ciancarini, P. and Moretti, R.},
  title = {Wiki-based requirements management for Business Process Reengineering},
  booktitle = {Wikis for Software Engineering, 2009. WIKIS4SE '09. ICSE Workshop
	on},
  year = {2009},
  pages = {14-24},
  month = {May},
  abstract = {This paper presents WikiReq, a project exploiting the semantic Mediawiki
	to manage both system and organizational requirements in the context
	of business process reengineering (BPR). Our work is based on three
	ideas: 1) using a semantic Wiki for requirements elicitation and
	management; 2) exploiting the Wiki platform to define an argumentation
	system for both synchronous and asynchronous discussions among stakeholders;
	3) achieving interoperability between the semantic Wiki and an integrated
	development environment (IDE) platform like Eclipse. Thus, we show
	how requirements acquired by the semantic MediaWiki can be exported
	in the Eclipse IDE in order to partially automate the translation
	of organizational business processes and system artifacts from the
	requirements description. In order to perform such a translation
	we use WikiReq in the context of the enterprise-service-implementation
	(ESI) method that we have defined. We present the WikiReq tool highlighting
	its relationships with model driven engineering and business process
	modeling.},
  doi = {10.1109/WIKIS4SE.2009.5069993},
  keywords = {business process re-engineering, information resources, open systemsWiki-based
	requirements management, argumentation system, business process reengineering,
	enterprise-service-implementation method, integrated development
	environment platform, interoperability, organizational business processes,
	semantic MediaWiki},
  timestamp = {2010.02.11}
}

@CONFERENCE{Aho2009,
  author = {Aho, P. and Merilinna, J. and Ovaska, E.},
  title = {Model-driven open source software development - The open models approach},
  booktitle = {4th International Conference on Software Engineering Advances, ICSEA
	2009},
  year = {2009},
  pages = {185-190},
  address = {Porto, Portugal},
  abbrev_source_title = {Int. Conf. Softw. Eng. Adv., ICSEA, Incl. SEDES: Simp. Estud. Doutoramento
	Eng. Softw.},
  abstract = {Model-Driven Development (MDD) aims to increase productivity in software
	development and manage the complexity of software by utilizing modelling
	to shift from programming in solution-space to modelling in problem-space.
	Another approach to increase productivity and experience significant
	cost savings is to utilize Open Source (OS) components in software
	development. This paper presents the state of the art of how to combine
	MDD methods with OS software development. The approach is called
	Open Models software development which is expected to combine the
	benefits of both worlds. The fundamental idea of Open Models development
	is to apply community-driven collaborative MDD. In this paper, Open
	Models development is exemplified by constructing Resource Availability
	Service (RAS). RAS is a web service for providing availability information
	about resources such as services, content, users and terminals. This
	paper shows that Open Models development is feasible from technical
	point of view although there are still great challenges in tooling.
	In addition, more empirical research is needed in studying attractiveness
	of Open Models. © 2009 IEEE.},
  affiliation = {VTT Technical Research Centre of Finland, Oulu, Finland},
  art_number = {5298439},
  author_keywords = {MDA; OSS; UML},
  document_type = {Conference Paper},
  doi = {10.1109/ICSEA.2009.37},
  isbn = {9780769537771},
  journal = {4th International Conference on Software Engineering Advances, ICSEA
	2009, Includes SEDES 2009: Simposio para Estudantes de Doutoramento
	em Engenharia de Software},
  keywords = {Cost saving; Empirical research; Model-driven; Model-driven development;
	Open source software development; Open sources; Resource availability;
	Software development; State of the art, Open systems; Productivity;
	Software architecture; Software design, Computer software},
  language = {English},
  review = {Throughout the history of software development, moving further off
	from programming in solution-space has been the cause of the largest
	leaps in developer productivity. The latest example was the move
	from Assembler to Third Generation Languages (3GLs) [10]. MDD is
	aiming to be the next step against the growing complexity of the
	software systems.},
  source = {Scopus},
  sponsors = {IARIA},
  timestamp = {2010.02.17},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70749149216&partnerID=40&md5=01413c76e574b96a0cc8d16043574d64}
}

@INPROCEEDINGS{Almeida:caise:2005,
  author = {Almeida, Eduardo Santana de and Alvaro, Alexandre and Lucrédio, Daniel
	and Garcia, Vinicius Cardoso and Meira, Silvio Romero de Lemos},
  title = {{Towards an Effective Software Reuse Process}},
  booktitle = {The 17th Conference on Advanced Information Systems Engineering (CAiSE'05)},
  year = {2005},
  address = {Porto, Portugal},
  publisher = {Springer-Verlag LNCS}
}

@INPROCEEDINGS{Bartelt2008,
  author = {Bartelt, Christian},
  title = {Consistence preserving model merge in collaborative development processes},
  booktitle = {CVSM '08: Proceedings of the 2008 international workshop on Comparison
	and versioning of software models},
  year = {2008},
  pages = {13--18},
  address = {New York, NY, USA},
  publisher = {ACM},
  abstract = {Specification by models plays a decisive role, during the development
	process of complex systems. The division and concurrency of labor
	in teams is a further characteristic of such development. Therefore
	an efficient configuration and variant management of resulting documents
	is essential. In practice, a lot of established configuration management
	systems like CVS and Subversion are available which provide a text
	based merge. Unfortunately these systems are inappropriate for the
	management of models because they ignore the syntactic and semantic
	structure which is specified by the associated meta-models. Especially
	during the merge of model versions the mentioned systems fails at
	the generation of a meta-model consistent model. In this paper a
	proposal is presented which is enabled to merge model versions in
	a model based, collaborative development process. Furthermore meta-model
	independent methods for consistent-receiving model merging are explained.},
  contributions = {Apresenta uma técnica de merge},
  doi = {http://doi.acm.org/10.1145/1370152.1370157},
  file = {:home/david/Dropbox/PROJETO DE MESTRADO/Artigos/Consistency Preserving Model Merge in Collaborative Development Processes - Bartelt2008.PDF:PDF;:C\:\\Documents and Settings\\david\\Meus documentos\\My Dropbox\\PROJETO DE MESTRADO\\Artigos\\Consistency Preserving Model Merge in Collaborative Development Processes - Bartelt2008.pdf:PDF},
  isbn = {978-1-60558-045-6},
  keywords = {collaborative development, inconsistency management, model driven
	engineering, model merge, model versioning, software configuration
	management},
  location = {Leipzig, Germany},
  refenciado = {Bendix2009},
  review = {Ver referências no artigo
	
	Fala sobre EMF},
  situation = {OK},
  theme = {Merge},
  timestamp = {2010.01.22}
}

@INPROCEEDINGS{Bendix2009,
  author = {Bendix, Lars and Emanuelsson, Par},
  title = {Collaborative work with Software Models - Industrial experience and
	requirements},
  booktitle = {Model-Based Systems Engineering, 2009. MBSE '09. International Conference
	on},
  year = {2009},
  pages = {60-68},
  month = {March},
  abstract = {When the initial problems of introducing and adopting model-driven
	development in a company have been handled, we want to go to work.
	That means that we have to supply our team of developers with a development
	environment and tools and processes that allow them to work efficiently.
	In many cases the team would like to work with models as if it was
	ldquojust another programming languagerdquo and use the same techniques
	and processes for team collaboration and coordination they are used
	to from traditional development. Unfortunately some of the traditional
	tools and processes that work so well for traditional development
	do not work at all for model-driven development. Version control
	functionality is usually a key part in coordinating the parallel
	work in a team and through a set of use cases, we arrive at a number
	of requirements to a model-driven development environment that must
	be available for a team of developers to work efficiently.},
  contributions = {Proposta de sistema.
	
	Assim, o trabalho foca nos requisitos de um ambiente orientadao a
	modelos, em especial no que concerne a colaboração desse ambiente,
	que precisam ser satisfeitos para que um time de desenvolvedores
	trabalhe eficientemente, através de casos de uso.
	
	São requisitos que um sistema que suporte MDD colaborativo deve ter.},
  doi = {10.1109/MBSE.2009.5031721},
  file = {:C\:\\Documents and Settings\\david\\Meus documentos\\My Dropbox\\PROJETO DE MESTRADO\\Artigos\\Collaborative Work with Software Models – Industrial Experience and Requirements_Bendix2009.pdf:PDF},
  keywords = {Collaborative Work; Industrial experience; Model driven development;
	Software model; Computer aided software engineering},
  objectives/proposal = {Definir os requisitos por meio de casos de uso para um ambiente colaborativo
	orientado a modelos},
  problem/context = {O problema identificado no trabalho de Bendix e Emanuelsson é que
	em muitos casos, um time de desenvolvedores gostaria de trabalhar
	com modelos da mesma forma que eles trabalhariam com o desenvolvimento
	tradicional.},
  review = {Texto em Português:
	
	
	O problema identificado no trabalho de Bendix e Emanuelsson é que
	em muitos casos, um time de desenvolvedores gostaria de trabalhar
	com modelos da mesma forma que eles trabalhariam com o desenvolvimento
	tradicional. Assim, o trabalho foca nos requisitos de um ambiente
	orientadao a modelos, em especial no que concerne a colaboração desse
	ambiente, que precisam ser satisfeitos para que um time de desenvolvedores
	trabalhe eficientemente.
	
	
	O trabalho acaba de maneira indireta identificando a importância de
	se ter um ambiente de MDD colaborativo:
	
	
	Quanto ao MDD, embora esteja ficando uma abordagem madura, ainda existem
	diversos problemas com ferramentas e processos necessários para suportar
	os desenvolvedores em seus trabalhos. Este suporte já existe em ambientes
	de desenvolvimento tradicional, mas parece ser ausente, ou muito
	incipiente, quando se trata de MDD.
	
	
	Bendix2009 aponta duas linhas de problemas relacionadas à MDD: a primeira
	linha se trata da introdução de MDD na indústria, a qual já está
	sendo tratada e a segunda se trata de como trabalhar com modelos.
	Os desenvolvedores gostariam de poder trabalhar com MDD da mesma
	forma que com a programação tradicional, mas o problema geral é como
	alcançar a colaboração quando se trata em trabalhar com modelos?
	
	
	Alguns problemas apontados, em relação à colaboração, são:
	
	Como capturar o histórios do desenvolvimento para faciliar a manutenção?
	
	Como compartilhar o que está sendo produzido por um time de maneira
	organizada e disciplinada?
	
	Essas necessidades são geralmente satistefitas atraveś do uso de um
	repositório com controle de versão.
	
	A consistência dos modelos e a geração de código. (acho melhor tirar
	pq n vou tratar sobre isso).
	
	
	No desenvolvimento tradicional ferramentas permitem ao time work and
	coordinate using sophisticated branching and merging strategies.
	Entretanto, por falta das mesmas ferramentas de apoio no contexto
	de MDD, as equipes de desenvolvedores trabalham de maneira muito
	mais restrita. Os desenvolvedores de MDD gostariam de trabalhar da
	mesma maneira que no desenvolvimeto tradicional, tanto porque é menos
	restrito, quanto porque eles já estão acostumados dessa forma quando
	programam da maneira tradicional.
	
	
	Muitos projetos não tem encontrado uma boa forma de alcançar os aspectos
	colaborativos do desenvolvimento e a evolução dos modelos UML. Claro
	que uma solução precisa ser encontrada, mas as soluções atuais são
	muitos restritas.
	
	
	... Modelagem (MDD) deveria ser compatível com qualquer técnica que
	resultasse no aumento de produtividade e qualidade
	
	
	Nós queremos ter a possibilidade de desenvolver em larga escala, modelos
	em paralelo por amplos times de desnvolvedores e ainda seremos capazes
	de garantir um alto nível de consistência e produtividade.
	
	
	Bendix2009 focam muito no merge e na consistência dos dados (ver os
	requisitos e a discussão: tópicos 3 e 4).
	
	----------------------------------------------------------------------
	
	Texto Original:
	
	
	For many different reasons, the use of model-driven development becomes
	more and more widespread. The model “technology” per se seems to
	have matured and can bring several advantages – amongst which is
	higher developer productivity. However, while the model-driven approach
	in itself is now becoming mature, there still seems to be many problems
	with the tools and processes that are needed to support the developers
	in their work. Such support is already in place with development
	environments for more traditional development, but seems to be absent
	– or in its infancy – when it comes to model-driven development.
	
	
	...Now that this first line of problems from introducing models has
	been dealt with, we start to see a second line of problems that has
	to do with how to work with models.
	
	
	The “general” problem is how to handle collaboration when working
	with models. Much of this has to do with how a team of developers
	can coordinate their work [1]. However, there are also other aspects,
	like how to capture the history of the development to facilitate
	maintenance (understanding the model through its evolution history)
	– or to facilitate adding new functionality based on what has
	
	happened in the past.
	
	
	We also need an organised and disciplined way of sharing what is being
	produced by the team. No team can work efficiently without team members
	working in parallel. Likewise we will need to carry out maintenance
	of older versions of the system in parallel with new development.
	These needs are usually satisfied through the use of a version-controlled
	repository. In both cases, branching and merging capabilities of
	such a repository can be used for this. Often we understand the present
	by looking at the past, so we would like to inspect the differences
	between the current version and some earlier version. This is all
	functionality that is at our service for traditional codedriven development,
	but which needs special tools for model-driven development.
	
	
	... the consistency of model and generated code, which has been a
	problem for many other modelbased approaches
	
	
	There is very little previous work on the requirements to useful environment
	support for modeldriven development – and to the best of our knowledge,
	there is virtually nothing on the 
	
	collaboration aspects of a team and how they can use version control
	techniques and processes in their dayto-day work as a team.
	
	
	The primary focus of Staron [12] is on the requirements for making
	the introduction of modeldriven development into industry work smoother.
	Whereas this means that many aspects deal with overcoming what we
	called the first line of problems of introducing model-driven development,
	there are also a few aspects related to collaborative working with
	model-driven development.
	
	
	In Figure 2 a) below, it is shown how tools make it possible for a
	team to work and coordinate using sophisticated branching and merging
	strategies when working with text (traditional programming languages).
	However, because of lack of the same tool support in the model-driven
	domain, our teams of developers have to work in the much more restricted
	way that is shown in Figure 2 b), where branches are few and merges
	back to the mainline are manual and remain “invisible”.
	
	
	The situation in Figure 2 a) is the one that our developers would
	like to be able to use, both because it is less restrictive and because
	it is what they are/were used to when working with traditional development.
	
	
	
	However many of the projects have not found a good way to handle collaborative
	aspects of the development and evolution of UML models. Of course
	a solution has to be found, but available solutions severely restrict
	several aspects of the development. One common solution is to avoid
	parallel development as far as possible in order to avoid merges.
	This can result in heavy planning work and static code owner assignments.
	Of course – a reasonable amount of planning is needed anyway and
	coordination of updates has to be done in some way. But to manage
	teams of hundreds of developers and guarantee that conflicting changes
	are not made can indeed be very complex
	
	
	
	Many projects would like to work in a feature oriented way. In this
	kind of development a multidisciplinary team develops a single feature
	of a system from start to end through all development phases. This
	development is quite different from having one team for requirements,
	one for design, one for test etc. All the feature teams would work
	on the same model and they should not have to do detailed synchronisation
	and planning between the teams. This kind of development requires
	efficient and reliable model merge.
	
	
	Projects that really want to work feature oriented can be forced to
	choose programming instead of modelling. That would be very unfortunate
	and something that we would like to see changed –modelling should
	be compatible with any kind of
	
	technique that results in increased productivity and quality.
	
	
	In Figure 2 a) below, it is shown how tools make it possible for a
	team to work and coordinate using sophisticated branching and merging
	strategies when working with text (traditional programming languages).
	However, because of lack of the same tool support in the model-driven
	domain, our teams of developers have to work in the much more restricted
	way that is shown in Figure 2 b), where branches are few and merges
	back to the mainline are manual and remain “invisible”.
	
	
	The situation in Figure 2 a) is the one that our developers would
	like to be able to use, both because it is less restrictive and because
	it is what they are/were used to when working with traditional development.
	
	
	We want to have the possibility to do large-scale development of models
	in parallel by large teams of developers and still be able to guarantee
	a high level of consistency and productivity.
	
	
	
	
	--------------------------------
	
	
	Bendix2009 indentificam uma série de casos de uso referentes à requisitos
	que um ambiente colaborativo deve ter para eliminar ou reduzir esses
	problemas. Alguns são mais genéricos e outros mais específicos do
	MDD. Este trabalho baseia-se no levantamente para identificar o diferencial
	comparado aos outros trbalhos. São requisitos genéricos:
	
	
	- Submeter o projeto à um controle de versão: os artefatos importantes
	para o sistema são identificados e é estabelecido uma estrutura para
	organizá-los em um repositório;
	
	- Trabalho isolado: é importante em alguns casos certificar-se de
	que apenas uma pessoa está desenvolvendo (fazendo alterações);
	
	- Integrar o trabalho: após alguma alteração local, seja realizada
	de maneira isolada, seja em paralelo; ela precisa ser integrada com
	a versão atual do repositório, o que é chamado de \textit{merge}
	(do inglês mesclar), ou seja, as mudanças realizadas devem ser atualizadas.
	Na maioria dos casos uma ferramenta pode fazer o \textit{merge},
	mas em caso de conflito, é necessária intervenção humana;
	
	- Verificar e validar o resultado do merge: as ferramentas de merge
	automático não são completamente confiáveis, uma vez que elas não
	levam em consideração nem a sintaxe e a semântica da linguagem de
	programação, nem a lógica do sistema.
	
	- Investifar o histórico: para se entender um código, é uma grande
	ajuda pode visualizar como ele foi desenvolvido ao longo do tempo
	(gancho para DR). Normalmente o histórico mostra a diferença entre
	duas ver~soes do mesmo componente.
	
	- Manter o desenvolvedor informado: pode ser interessanto ao desenvolvedor
	saber quem está trabalhando em que, que alterações foram realizadas
	e quais as consequencias de uma integração na ver~sao atual do sistema.
	Para isso os desenvolvedores precisam ter uma separação individual
	no repositório. Seria necessário mostrar as diferenças não somente
	entre o workspace e o repositório, mas entre dois workspaces, por
	exemplo.
	
	- Manter a versão anterior
	
	
	Como casos de uso mais específicos do MDD, tem-se:
	
	
	- Desenvolvimento do modelo da arquitetura (essencialmente apenas
	gráfico, sem a necessidade da ação do código): a partir dos requisitos
	do sistema, um modelo de arquitetura deve ser desenvolvido. O modelo
	da arquitetura fornece o contexto do sistema para os participantes
	do projeto, além de descrever as interfaces do sistema.
	
	- Desenvolvimento do modelo de design: fornece o detalhamento do sistema
	que pode ser usado para gerar o código completo. 
	
	- Atualização de modelo sem merge: ao se criar uma versão nova, a
	ferramenta de controle de versão checa pelo \textit{timestamp} do
	arquivo que não existe outra versão anterior no repositório, não
	havendo merge entre modelos apenas a inserção desse modelo no repositorio.
	
	- Atualização de modelo com merge: o objetivo é criar uma nova versão
	de alguns itens de configuração do modelo. Para isso o desenvolvedor
	do modelo checa uma série de itens, o editor do modelo é usado para
	atualizar o modelo, a ferramenta de controle de versão analisa se
	há atualizações dos itens. A ferramenta de merge de modelos compara
	os itens alterados com os itens do modelo do repositório e faz então
	o merge entre eles, gerando um modelo mais atual, desde que todos
	os conflitos tenham sido resolvidos.
	
	- Atualização do modelo com merge complexo: semelhante ao caso anterior,
	entretanto, a ferramenta de merge compara os itens, mas não consegue
	fazer o merge automático entre eles. Dessa forma o usuário é questionado
	sobre como combinar os resultados de dois modelos conflitantes.},
  situation = {Ativo},
  theme = {Requisitos},
  timestamp = {2010.01.20}
}

@INPROCEEDINGS{Bendix2008,
  author = {Bendix, Lars and Emanuelsson, P\"{a}r},
  title = {Diff and merge support for model based development},
  booktitle = {CVSM '08: Proceedings of the 2008 international workshop on Comparison
	and versioning of software models},
  year = {2008},
  pages = {31--34},
  address = {New York, NY, USA},
  publisher = {ACM},
  abstract = {Feature oriented development using models has many advantages. However,
	there are serious obstacles when it comes to using this approach
	because of lack of support for teamwork when using models. We believe
	that one solution is a better connection between research and problems
	-- and we suggest some strategies to pursue to achieve better support
	for teamwork when using models.},
  doi = {http://doi.acm.org/10.1145/1370152.1370161},
  file = {:home/david/Dropbox/PROJETO DE MESTRADO/Artigos/Diff and Merge Support for Model Based Development - Bendix2008.pdf:PDF},
  isbn = {978-1-60558-045-6},
  keywords = {diff, merge, models, parallel work, versioning},
  location = {Leipzig, Germany},
  refenciado = {Bendix2009},
  situation = {Stand by},
  theme = {Merge},
  timestamp = {2010.01.22}
}

@INPROCEEDINGS{Blois2005,
  author = {Blois, A. P. and Werner, C. M. L. and Becker, K.},
  title = {Towards a Components Grouping Technique within a Domain Engineering
	Process},
  booktitle = {31st IEEE EUROMICRO Conference on Software Engineering and Advanced
	Applications (EUROMICRO-SEAA), Component-Based Software Engineering
	Track},
  year = {2005},
  pages = {18-27},
  address = {Porto, Portugal},
  timestamp = {2010.02.17}
}

@ARTICLE{Booch2003,
  author = {Grady Booch and Alan W. Brown},
  title = {Collaborative Development Environments},
  journal = {Advances in Computers},
  year = {2003},
  volume = {59},
  pages = {2-29},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  review = {- Um CDE é um espaço visual onde todos os stakeholders do projeto,
	mesmo distribuídos em tempo ou espaço, podem negociar, fazer brainstorm,
	discutir, compartilhar conhecimento e geralmente trabalham em conjunto
	para realizar algumas tarefas.
	
	
	- Colaboração é essencial para todos os domínios.
	
	
	- IDEs são essencialmente centradas no desenvolvedor, significando
	que sua experiência de usuário primária foca no desenvolvedor individual,
	enquanto que CDEs são essencialmente centrados no time, significando
	que seu primary user experience é focado nas necessidades do time
	(mas com pontos de entrada diferentes para diferentes indivíduos).
	
	
	
	------------------------
	
	
	
	- A collaborative development environment (CDE) is a virtual space
	wherein all the
	
	stakeholders of a project – even if distributed by time or distance
	– may negotiate,
	
	brainstorm, discuss, share knowledge, and generally labor together
	to carry out some
	
	task, most often to create an executable deliverable and its supporting
	artifacts.
	
	
	- Collaboration is essential to every engineering domain.
	
	
	- IDEs are essentially developer-centric, meaning that their primary
	user experience
	
	focuses on the individual developer, whereas CDEs are essentially
	team-centric, meaning
	
	that their primary user experience focuses on the needs of the team
	(but with points of
	
	entry for different individuals). Psychologically, this is a subtle
	yet very important shift
	
	of perspective.
	
	
	- In order to best understand the requirements for a CDE, it is reasonable
	to first
	
	understand the social dynamics of the individual, the team and a team
	of teams.
	
	Surprisingly, however, there exist very few empirical studies that
	highlight what
	
	developers really do with their time. There are some soft studies,
	such as found in the
	
	experiences of Gerald Weinberg [2], Tom DeMarco [3], and Larry Constantine
	[4].},
  timestamp = {2010.02.10}
}

@INPROCEEDINGS{Bozzon,
  author = {Bozzon, Alessandro and Comai, Sara and Fraternali, Piero and Carughi,
	Giovanni Toffetti},
  title = {Conceptual modeling and code generation for rich internet applications},
  booktitle = {ICWE '06: Proceedings of the 6th international conference on Web
	engineering},
  year = {2006},
  pages = {353--360},
  address = {New York, NY, USA},
  publisher = {ACM},
  doi = {http://doi.acm.org/10.1145/1145581.1145649},
  isbn = {1-59593-352-2},
  location = {Palo Alto, California, USA}
}

@BOOK{Broekman2002,
  title = {Testing Embedded Software},
  publisher = {Addison-Wesley Professional},
  year = {2002},
  author = {Bart Broekman and Edwin Notenboom},
  month = {12},
  isbn = {9780321159861},
  price = {$52.99},
  review = {Sistema Embarcado é um termo genérico para uma ampla gama de sistemas,
	como por exemplo: celulares, sistemas de transporte ferroviário,
	aparelhos auditivos, marca passos, sistema de monitoramento de mísseis,
	entre outros. No entanto, todos os sistemas embarcados têm uma características
	em comum: interagir com o mundo real, controlando algum hardware
	específico \cite{Broekman2002}. A figura \ref{fig:esq_gen_sis_emb}
	apresenta um esquema genérico da arquitetura de um sistema embarcado.
	
	
	O software é armazenado (embarcado) num tipo de memória não volátil
	(NVM). Geralmente é uma memória ROM, mas o software também pode ser
	armazenado em memória \textit{flash}, em HD (\textit{hard disk})
	ou \textit{downloaded} via uma rede ou satélite. O software embarcado
	é compilado para um processador específico, com uma unidade de processamento
	(\textit{processing unit}) que opera com uma quantidade específica
	de memória RAM \cite{Broekman2002}.
	
	
	Como a unidade de processamento trabalha apenas com sinais digitais
	(desconsirando os computadores analógicos) e o ambiente lida, provavelmente,
	com sinais analógicos, os conversores analógicos-digitais (A/D -
	ou digitais analógicos (D/A), no caso do sistema embarcado enviar
	uma mensagem, que pode ser ou não executada pelo atuador) intermediam
	a comunicação entre o ambiente e o sistema. A unidade de processamente
	manipula toda entrada e saída de sinais através de uma camada dedicada
	para isso (\textit{input/output - I/O layer}). O sistema interage
	com a planta e com outros sistemas através de interfaces específicas
	(\textit{Specific interfaces}) \cite{Broekman2002}.
	
	
	
	----------------------------------
	
	
	“Embedded system” is one of those terms that do not really say what
	exactly it
	
	is about. It is a generic term for a broad range of systems covering,
	for example,
	
	cellular phones, railway signal systems, hearing aids, and missile
	tracking sys-
	
	tems. Nevertheless, all embedded systems have a common feature in
	that they
	
	interact with the real physical world, controlling some speciﬁc hardware.
	Figure
	
	1.2 shows a generic layout, which is applicable to virtually all embedded
	sys-
	
	tems, pointing out the typical components of an embedded system.
	
	
	An embedded system interacts with the real world, receiving signals
	through
	
	sensors and sending output signals to actors that somehow manipulate
	the envi-
	
	ronment.
	
	
	
	The embedded software of the system is stored in any kind of non-volatile
	
	memory (NVM). Often this is ROM, but the software can also be in ﬂash
	cards or
	
	on hard disk or CD-ROM, and downloaded via a network or satellite.
	The embedded software is compiled for a particular target processor,
	the processing unit, which usually requires a certain amount of RAM
	to operate.
	
	
	As the processing unit can only process digital signals (ignoring
	analog computers for now) while the environment possibly deals with
	analog signals, digital–analog conversions (two-way) take place.
	The processing unit handles all input and output (I/O) of signals
	through a dedicated I/O layer. The embedded system interacts with
	the plant and possibly other (embedded) systems through specific
	interfaces.
	
	Embedded systems may draw power from a general source or have their
	own dedicated power supply, such as from batteries.},
  timestamp = {2010.02.17},
  totalpages = {368},
  url = {http://amazon.com/o/ASIN/0321159861/}
}

@INPROCEEDINGS{Conmy2007,
  author = {Conmy, Philippa and Paige, Richard F.},
  title = {Challenges when using Model Driven Architecture in the development
	of Safety Critical Software},
  booktitle = {Model-Based Methodologies for Pervasive and Embedded Software, 2007.
	MOMPES '07. Fourth International Workshop on},
  year = {2007},
  pages = {127-136},
  month = {March},
  abstract = {The model driven architecture (MDA) is an approach to software engineering
	in which models are systematically developed and transformed into
	code. This paper discusses some of the issues which would need to
	be overcome when attempting to certify a safety critical design or
	software developed with the MDA approach, partially based on our
	experience with an avionics software case study. We particularly
	focus on the need to certify MDA artefacts and produce a compelling
	system safety case},
  doi = {10.1109/MOMPES.2007.4},
  file = {:home/david/Dropbox/PROJETO DE MESTRADO/Artigos/SEC/Challenges when using Model Driven Architecture in the development of Safety Critical Software - Conmy2007.pdf:PDF},
  keywords = {formal specification, safety-critical software, software architectureavionics
	software, model driven architecture, safety critical software, software
	engineering},
  problem/context = {Problemas que devem ser solucionados para permitir que a abordagem
	MDA possa ser usada para desenvolve sistemas críticos de segurança},
  review = {Fazem um levantamento dos ... necessários para validar a abordagem
	MDA no processo de desenvolvimento de sistemas críticos de segurança.
	Uma proposição do trabalho é que é possível usar MDA para apoiar
	o desenvolvimento de software ou o design de sistemas para sistemas
	críticos de segurança.
	
	
	
	Ainda é incerto se a abordagem MDA (e suas implementações atuais)
	poderiam ser suficientemente rigorosas para a alta integridade do
	desenvolvimento de softwares críticos. Contudo, vale a pena examinar
	essa possibilidade por muitas razões. Primeiramente, uma vez que
	a habilidade de lidar com mudanças e reuso é fundamental para o MDA
	então existe a possibilidade da abordagem MDA poder ser usada para
	certificações incrementais. Em segundo, a MDA suporta o desenvolvimento
	modular, usando transformações para produzir modelos de componentes
	fundidos (mesclados). Isto é potencialmente compatível com uma abordagem
	de certificação modular. Também é importante notar que a abordagem
	MDA tem sido usada para implementar missões criticas de software,
	?? portanto seu uso relacionado a um domínio não é inédito \cite{Conmy2007}
	
	
	Apresentam alguns problemas que devem ser resolvidos para permitir
	que MDA possa ser usada no desenvolvimento de sistemas críticos de
	segurança
	
	
	It is unclear if the MDA approach (and its current implementations)
	would be rigourous enough (or could be adapted to be rigourous enough)
	for very high integrity safety critical software development. However,
	it is worth examining the possibility for a number of reasons. First,
	since the ability to deal with change and reuse is fundamental to
	MDA then there is the possibility that an MDA approach could be used
	to support incremental certifcation. Second, MDA supports modular
	development, using transformations to produce models of merged components.
	This is is potentially compatible with a modular certifcation approach.
	It is also worth noting that the MDA approach has been used to implement
	mission critical software [8], therefore its use in a related (although
	not such high integrity) domain is not unheard of.},
  theme = {SE}
}

@ARTICLE{Deursen2000,
  author = {van Deursen, Arie and Klint, Paul and Visser, Joost},
  title = {Domain-specific languages: an annotated bibliography},
  journal = {SIGPLAN Not.},
  year = {2000},
  volume = {35},
  pages = {26--36},
  number = {6},
  abstract = {We survey the literature available on the topic of domain-specific
	languages as used for the construction and maintenance of software
	systems. We list a selection of 75 key publications in the area,
	and provide a summary for each of the papers. Moreover, we discuss
	terminology, risks and benefits, example domain-specific languages,
	design methodologies, and implementation techniques.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/352029.352035},
  issn = {0362-1340},
  publisher = {ACM},
  review = {A specific approach provides a much better solution for a smaller
	set of problems. 
	
	
	
	A domain-specific language (DSL) is a programming language or executable
	specification language that offers, through appropriate notations
	and abstractions, expressive power focused on, and usually restricted
	to, a particular problem domain.},
  theme = {DSL},
  timestamp = {2010.02.06}
}

@MISC{DrupalArquitetura,
  author = {Drupal},
  title = {The Drupal overview - The Drupal flow},
  year = {2009},
  note = {Último acesso em 19/02/2010.},
  owner = {david},
  timestamp = {2010.02.19},
  url = {http://drupal.org/getting-started/before/overview}
}

@MISC{eclipse,
  author = {Eclipse},
  title = {About the Eclipse Foundation - What is Eclipse and the Eclipse Foundation?},
  year = {2010},
  note = {Último acesso em 17/02/2010.},
  owner = {david},
  timestamp = {2010.02.17},
  url = {http://www.eclipse.org/org/}
}

@MISC{eclipseModeling,
  author = {Eclipse},
  title = {Eclipse Modeling Project},
  year = {2010},
  note = {Último acesso em 17/02/2010.},
  owner = {david},
  timestamp = {2010.02.17},
  url = {http://www.eclipse.org/modeling/}
}

@MISC{gmf,
  author = {Eclipse},
  title = {The Eclipse Graphical Modeling Framework (GMF)},
  year = {2010},
  note = {Último acesso em 17/02/2010.},
  owner = {david},
  timestamp = {2010.02.17},
  url = {http://www.eclipse.org/modeling/gmf/}
}

@MISC{helpEMF,
  author = {Eclipse},
  title = {EMF Developer Guide},
  year = {2010},
  note = {Último acesso em: 19/02/2010.},
  owner = {david},
  timestamp = {2010.02.19},
  url = {http://help.eclipse.org/galileo/index.jsp}
}

@MISC{jet,
  author = {Eclipse},
  title = {Model To Text (M2T) - JET},
  year = {2010},
  note = {Último acesso em 17/02/2010.},
  owner = {david},
  timestamp = {2010.02.17},
  url = {http://www.eclipse.org/modeling/m2t/?project=jet#jet}
}

@MISC{emfFaq,
  author = {Eclipse},
  title = {EMF/FAQ - What is EMF?},
  year = {2009},
  note = {Último acesso em 17/02/2010.},
  owner = {david},
  timestamp = {2010.02.17},
  url = {http://wiki.eclipse.org/index.php/EMF/FAQ#What_is_EMF.3F}
}

@ARTICLE{Ellis1991,
  author = {Ellis, Clarence A. and Gibbs, Simon J. and Rein, Gail},
  title = {Groupware: some issues and experiences},
  journal = {Commun. ACM},
  year = {1991},
  volume = {34},
  pages = {39--58},
  number = {1},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/99977.99987},
  fonte = {dadsa},
  issn = {0001-0782},
  publisher = {ACM},
  review = {The goal of groupware is to assist groups in communicating, in collaborating,
	
	and in coordinating their activities. Specifically, we define
	
	groupware as: computer-based systems that support
	
	groups of people engaged in a common task (or goal) and that provide
	
	an interface to a shared environment.},
  timestamp = {2010.02.16}
}

@ARTICLE{Elrufaie2005,
  author = {Elharith Elrufaie and David A. Turner},
  title = {A Wiki Paradigm for use in IT courses},
  journal = {Information Technology: Coding and Computing, International Conference
	on},
  year = {2005},
  volume = {2},
  pages = {770-771},
  abstract = {We present a system currently used by the department of Computer Science
	at the California State University, San Bernardino. The system extends
	the traditional wiki paradigm with features that make it useful as
	an instructional aid for IT courses. The most notable feature includes
	the use of strict XHTML for user input rather than traditional wiki
	markup. The use of XHTML serves three purposes: it requires IT students
	to learn XML syntax and concepts, it requires students to learn HTML,
	and it provides more flexibility to students and instructors when
	constructing pages. Additionally, we added other features not commonly
	found in wiki systems to better accommodate the needs of the classroom.},
  address = {Los Alamitos, CA, USA},
  doi = {http://doi.ieeecomputersociety.org/10.1109/ITCC.2005.54},
  fonte = {scopus},
  isbn = {0-7695-2315-3},
  publisher = {IEEE Computer Society},
  timestamp = {2010.02.16}
}

@INPROCEEDINGS{France2007,
  author = {Robert France and Jim Bieman and Betty H. C. Cheng},
  title = {Repository for Model Driven Development {(ReMoDD})},
  booktitle = {Models in Software Engineering},
  year = {2007},
  volume = {4364},
  series = {Lecture Notes in Computer Science},
  pages = {311--317},
  publisher = {Springer Berlin / Heidelberg},
  abstract = {TheRepository for MDD(ReMoDD) project is concerned with developing
	a repository that will contain artifacts that support research and
	education in model-driven development (MDD). The ReMoDD platform
	will also provide interfaces and interchange mechanisms that will
	enable a variety of tools to retrieve artifacts from the repository
	and submit candidate artifacts to the repository. ReMoDD artifacts
	will include documented MDD case studies, examples of models reflecting
	good and bad modeling practices, reference models (including metamodels)
	that can be used as the basis for comparing and evaluating MDD techniques,
	generic models and transformation reflecting reusable modeling experience,
	descriptions of modeling techniques, practices and experiences, and
	modeling exercises and problems that can be used to develop classroom
	assignments and projects. In this paper we outline plans for developing
	ReMoDD.},
  doi = {10.1007/978-3-540-69489-2_38},
  isbn = {978-3-540-69488-5},
  issn = {0302-9743 (Print) 1611-3349 (Online)},
  review = {[Motivação]
	
	
	
	[Proposta]
	
	
	
	[Como os ambientes colaborativos são aplicados]
	
	
	
	[Descrição do projeto (Resumo)]
	
	O sistema ainda está na fase de elicitação de requisitos, sendo que
	sua estrutura está toda planejada
	
	
	[Ganhos do MDD com o suporte colaborativo]
	
	
	
	[Metodologia]
	
	Criar um conselho consultivo (fiscalização), organização de workshops,
	instituições e faculdades menores, promoverá a divulgação, planeja
	o desenvolvimento do repositório},
  subject_collection = {Computer Science},
  timestamp = {2010.02.17},
  url = {http://www.springerlink.com/content/84662v5730261t35/}
}

@INPROCEEDINGS{France:2007:fose,
  author = {France, Robert and Rumpe, Bernhard},
  title = {Model-driven Development of Complex Software: A Research Roadmap},
  booktitle = {29th International Conference on Software Engineering 2007 - Future
	of Software Engineering},
  year = {2007},
  pages = {37--54},
  address = {Minneapolis, MN, USA},
  publisher = {IEEE Computer Society}
}

@TECHREPORT{Gruber1991,
  author = {Thomas R. Gruber and Thomas R. Gruber and Daniel M. Russell and Daniel
	M. Russell},
  title = {Design Knowledge and Design Rationale: A Framework for Representation,
	Capture, and Use},
  institution = {Laboratory, Stanford University},
  year = {1991},
  file = {:home/david/Dropbox/PROJETO DE MESTRADO/Artigos/Design Knowledge and Design Rationale\: A Framework for Representation, Capture, and Use - Gruber1991.pdf:PDF},
  review = {Design rationales are
	
	explanations. They explain the relationships between the structure,
	behavior,
	
	and function of artifacts, such as how structure implements function,
	or how
	
	behavior emerges from structure. They also explain the decision-making
	
	process. This second kind of rationale is based on the history of
	design
	
	decisions, describing how alternatives were considered and evaluated,
	and
	
	how decisions were made over time.
	
	
	\cite{Gruber1991} define \textit{Desgin Rationale} como sendo explicações.
	Elas explicam as relações entre a estrutura, comportamento e as funções
	dos artefatos, tais como a maneira que a estrutura implementa uma
	função, ou como o comportamento emerge da estrutura. Eles também
	explicam a tomada de decisão do processo. Este segundo tipo de \textit{rationale}
	é baseado no histórico das decisões de design, descrevendo como as
	alternativas foram consideradas e avaliadas e como as decisões foram
	tomadas ao longo do tempo.},
  theme = {DR},
  timestamp = {2010.02.02}
}

@ARTICLE{Grudin1994,
  author = {Grudin, J.},
  title = {Computer-supported cooperative work: history and focus},
  journal = {Computer},
  year = {1994},
  volume = {27},
  pages = {19 -26},
  number = {5},
  month = {May},
  abstract = {CSCW and groupware emerged in the 1980s from shared interests among
	product developers and researchers in diverse fields. Today, it must
	overcome the difficulties of multidisciplinary interaction. This
	article describes the people and the work found under the CSCW umbrella.
	Issues considered include: research and design areas, software development,
	office automation, small-group versus systems approach, US and European
	differences; and the history of groupware},
  doi = {10.1109/2.291294},
  issn = {0018-9162},
  keywords = {CSCW;Europe;US;computer-supported cooperative work;design area;groupware;history;multidisciplinary
	interaction;office automation;product developers;research;small-group
	approach;software development;systems approach;groupware;history;office
	automation;software engineering;},
  timestamp = {2010.02.19},
  url = {http://research.microsoft.com/en-us/um/people/jgrudin/past/Papers/IEEE94/IEEEComplastsub.html}
}

@ARTICLE{Hailpern2006,
  author = {Hailpern, B. and Tarr, P.},
  title = {Model-driven development: the good, the bad, and the ugly},
  journal = {IBM Syst. J.},
  year = {2006},
  volume = {45},
  pages = {451--461},
  number = {3},
  address = {Riverton, NJ, USA},
  issn = {0018-8670},
  publisher = {IBM Corp.},
  timestamp = {2010.02.04}
}

@OTHER{Heering2008,
  author = {Jan Heering},
  month = {November},
  owner = {david},
  timestamp = {2010.02.06},
  title = {Developments in Domain-Specific Languages},
  url = {http://homepages.cwi.nl/~jan/Developments_in_DSLs.pdf},
  year = {2007}
}

@INPROCEEDINGS{Jang2006,
  author = {Jang, Soobaek and Green, Tonya M.},
  title = {Best Practices on Delivering A Wiki Collaborative Solution for Enterprise
	Applications},
  booktitle = {Collaborative Computing: Networking, Applications and Worksharing,
	2006. CollaborateCom 2006. International Conference on},
  year = {2006},
  pages = {1-9},
  month = {Nov.},
  abstract = {Wikis have become a hot topic in the world of collaboration tools.
	Wikipedia.org, a vast, community-driven encyclopedia, has proven
	to be an invaluable information resource that has been developed
	through collaboration among thousands of people around the world.
	Today wikis are increasingly being employed for a wide variety of
	uses in business. Consequently, one of the key challenges is to enable
	wikis to interoperate with informational and business process applications.
	The ability to dynamically change the content of Webpages and reflect
	the changes within an enterprise application brings the power of
	collaboration to business applications. This paper includes general
	information about wikis and describes how to use a wiki solution
	within an enterprise application. Integrating an enterprise application
	with a wild permits real-time updates of pages in the application
	by certain groups of experts, without deploying files from the Web
	application server},
  doi = {10.1109/COLCOM.2006.361852},
  keywords = {Web sites, business data processing, open systemsWeb application server,
	Web page, Web-based collaboration, Wikipedia.org, business process
	application, collaboration design, collaboration tools, distributed
	technology, enterprise application, group collaboration, information
	resource, informational process application, interoperate, wiki collaborative
	solution},
  timestamp = {2010.02.16}
}

@ARTICLE{Jing2008,
  author = {Huang Jing and Yang Fan},
  title = {Usability of Wiki for Knowledge Management of Knowledge-Based Enterprises},
  journal = {Knowledge Acquisition and Modeling, International Symposium on},
  year = {2008},
  volume = {0},
  pages = {201-205},
  address = {Los Alamitos, CA, USA},
  doi = {http://doi.ieeecomputersociety.org/10.1109/KAM.2008.133},
  isbn = {978-0-7695-3488-6},
  publisher = {IEEE Computer Society},
  timestamp = {2010.02.16}
}

@MISC{JoomlaArquitetura,
  author = {Joomla!},
  title = {Documentation - Framework},
  year = {2010},
  note = {Último acesso em: 19/02/2010.},
  owner = {david},
  timestamp = {2010.02.19},
  url = {http://docs.joomla.org/Framework}
}

@INPROCEEDINGS{Junqueira2008,
  author = {Junqueira, Daniel C. and Bittar, Thiago J. and Fortes, Renata P.
	M.},
  title = {A fine-grained and flexible version control for software artifacts},
  booktitle = {SIGDOC '08: Proceedings of the 26th annual ACM international conference
	on Design of communication},
  year = {2008},
  pages = {185--192},
  address = {New York, NY, USA},
  publisher = {ACM},
  doi = {http://doi.acm.org/10.1145/1456536.1456576},
  isbn = {978-1-60558-083-8},
  location = {Lisbon, Portugal},
  timestamp = {2010.02.19}
}

@BOOK{Kleppe2003,
  title = {MDA Explained: The Model Driven Architecture: Practice and Promise},
  publisher = {Addison-Wesley Longman Publishing Co., Inc.},
  year = {2003},
  author = {Kleppe, Anneke G. and Warmer, Jos and Bast, Wim},
  address = {Boston, MA, USA},
  isbn = {032119442X},
  timestamp = {2010.02.04},
  url = {http://proquest.safaribooksonline.com/0-321-19442-X/ch01lev1sec1#X2ludGVybmFsX0ZsYXNoUmVhZGVyP3htbGlkPTAtMzIxLTE5NDQyLVgvdmlpJmltYWdlcGFnZT12aWk=}
}

@INPROCEEDINGS{Komi-Sirvioe2005,
  author = {Seija Komi-Sirviö and Maarit Tihinen},
  title = {Lessons learned by participants of distributed software development},
  booktitle = {Knowledge and Process Management},
  year = {2005},
  volume = {12},
  abstract = {The maturation of the technical infrastructure has enabled the emergence
	and growth of distributed software development. This has created
	tempting opportunities for companies to distribute their software
	development, for example, to economically favourable countries so
	as to gain needed expertise or to get closer to customers. Nonetheless,
	such distribution potentially creates problems that need to be understood
	and addressed in order to make possible the gains offered. To clarify
	and understand the most difficult problems and their nature, a survey
	of individuals engaged in distributed software development was conducted.
	The purpose of this survey was to gather and share lessons learned
	in order to better understand the nature of the software development
	process when operating in a distributed software development environment
	and the problems that may be associated with such distributed processes.
	Through a clear appreciation of the risks associated with distributed
	development it becomes possible to develop approaches for the mitigation
	of these risks. This paper presents the results of the survey, focusing
	on the most serious problems raised by the respondents. Some practical
	guidelines that have been developed by industry to overcome these
	problems are also briefly summarized. Copyright © 2005 John Wiley
	& Sons, Ltd.},
  doi = {http://dx.doi.org/10.1002/kpm.225},
  file = {:home/david/Dropbox/PROJETO DE MESTRADO/Artigos/Lessons Learned by Participants of Distributed Software Development - Komi-Sirvioe2005.pdf:PDF},
  owner = {david},
  relevance = {5},
  review = {Komi-Sirviö identificam ``Ambientes e ferramentas de desenvolvimento''
	e ``Design Knowledge'' como dois entre os principais problemas do
	DDS.[posso falar desses problemas e ter mais texto]},
  timestamp = {2010.02.10}
}

@INPROCEEDINGS{Lanubile2009,
  author = {Lanubile, Filippo},
  title = {Collaboration in Distributed Software Development},
  booktitle = {Software Engineering, International Summer Schools, ISSSE},
  year = {2009},
  pages = {174--193},
  address = {Berlin, Heidelberg},
  publisher = {Springer-Verlag},
  abstract = {Software development is an intense collaborative process where success
	depends on the ability to create, share and integrate information.
	Given the trend towards globalization in the software development
	industry, distance creates an additional challenge to development
	processes, as fewer opportunities for rich interaction and lower
	frequencies of direct communication. The chapter introduces a taxonomy
	of software engineering tools for distributed projects and presents
	collaborative development environments, ranging from classic platforms
	for dispersed developers in open source software projects to modern
	environments for flexible and distributed processes. Moreover, it
	introduces computer-mediated communication theories which reveal
	some patterns of tool usage to overcome the challenges of distance.
	Building upon the theoretical background of media selection, the
	chapter summarizes research activities aimed to build an evidence-based
	model of task-technology fit for communication-intensive activities
	such as distributed requirements workshops.},
  book = {Software Engineering: International Summer Schools, ISSSE 2006-2008,
	Salerno, Italy, Revised Tutorial Lectures},
  doi = {http://dx.doi.org/10.1007/978-3-540-95888-8_7},
  isbn = {978-3-540-95887-1},
  keywords = {Distributed software development, collaborative development environments,
	computer-supported cooperative work, global software development},
  problem/context = {This chapter focuses on requirements engineering as an appropriate
	domain for studying distributed engineering teams.},
  review = {- Ferramentas ajudam nas atividades de desenvolvimento de software,
	prestando assistências para projetos distribuído. Um exemplo são
	as ferramentas CASE. A partir dos requisitos de gerenciamento para
	a modelagem visual de ambos os artefatos de software e customização
	de processos de software. Colaboração no desenvolvimento de software
	tende ser em torno de artefatos de software formais ou semiformais.
	De acordo com 38, colaboração baseada em modelos é o que diferencia
	a colaboração em engenharia de software de atividades de colaboração
	mais gerais, a qual falta o foco no uso de modelos para criar conhecimentos
	compartilhados.
	
	
	- Interoperabilidade e uma interface para usuário familiar proveem
	fortes motivações para integrar soluções específicas e groupware
	genéricos dentro de ambientes de desenvolvimento colaborativo, chamados
	de CDE. Um CDE prove um espaço de trabalho com um conjunto de ferramentas
	padronizadas para serem usadas pelo time global de desenvolvimento.
	Antigamente, CDEs foram desenvolvidas dentro de projetos open source,
	porque estes projetos, no início, era desenvolvido por indivíduos
	dispersos. Hoje, um numero de CDE estao disponíveis como produtos
	comerciais, iniciativas open source ou protótipos de pesquisa que
	permitem o desenvolvimento distribuído.
	
	
	- O desenvolvimento de software é um processo intensamente colaborativo
	onde o sucesso depende da habilidade de criar, compartilhar e integrar
	informação [37].
	
	
	--------------------------------------------
	
	
	- ... most work in collaborative environments for distributed development
	has focused on code-specific tasks rather than on other software
	engineering activities at a higher level of abstraction like re-
	
	quirements engineering or software design [apud 35]
	
	
	- ... Erran Carmel lists the six main ‘catalyst’ factors, or potential
	benefits, which have driven to distributed software development.
	
	
	- Product and process modeling. This function encompasses the core
	features of what
	
	was called Computer Aided Software Engineering (CASE), from requirements
	
	management to visual modeling of both software artifacts and customized
	software
	
	processes. Collaboration in software development tends to be around
	the creation of
	
	formal or semiformal software artifacts. According to [38], model-based
	collaboration
	
	is what distinguishes software engineering collaboration from more
	general collabora-
	
	tion activities which lack the focus on using the models to create
	shared meanings.
	
	
	- Interoperability and a familiar user interface provide strong motivations
	to inte-
	
	grate task-specific solutions and generic groupware into collaborative
	development
	
	environments (CDE). A CDE provides a project workspace with a standardized
	tool-
	
	set to be used by the global software team. Earliest CDE were developed
	within open
	
	source software (OSS) projects because OSS projects, from the beginning,
	have been
	
	composed of dispersed individuals. Today a number of CDE are available
	as com-
	
	mercial products, open source initiatives or research prototypes to
	enable distributed
	
	software development.
	
	
	- Software development is an intense collaborative process where success
	depends on
	
	the ability to create, share and integrate information [37].},
  timestamp = {2010.01.27}
}

@MASTERSTHESIS{Lara2005,
  author = {Silvana Maria Affonso de Lara},
  title = {Um Suporte à Captura Informal de Design Rationale},
  school = {Universidade de São Paulo},
  year = {2005},
  month = {November},
  owner = {david},
  timestamp = {2010.02.17}
}

@INPROCEEDINGS{LARA2004,
  author = {LARA, Silvana Maria Affonso de ; FORTES, R. P. M.},
  title = {Um Suporte à captura Informal de Design Rationale para Documentação
	de Especificação de requisitos.},
  booktitle = {Webmedia \& LA-WEB Joint Conference,},
  year = {2004},
  editor = {Editora COC},
  volume = {2},
  number = {39-41},
  address = {Ribeirão Preto-SP.},
  owner = {david},
  timestamp = {2010.02.19}
}

@ARTICLE{Levytskyy2009,
  author = {Andriy Levytskyy and Hans Vangheluwe and Leon J.M. Rothkrantz and
	Henk Koppelaar},
  title = {MDE and customization of modeling and simulation web applications},
  journal = {Simulation Modelling Practice and Theory},
  year = {2009},
  volume = {17},
  pages = {408 - 429},
  number = {2},
  abstract = {In this paper, we present a model-driven approach to construction
	of web-based collaborative environments that could be efficiently
	tailored to modeling and simulation needs of an arbitrary number
	of M&S application domains. To achieve broad applicability, our approach
	is based on general concepts and taxonomies in fields of Modeling
	and Simulation, Distributed Systems, and Collaborative Software.
	Such stable concepts constitute the collaborative Modeling and online
	Simulation (cMoS) framework. cMoS provides a general basis for a
	family of Web-Based M&S applications. Specific M&S applications are
	supported through customization of the variation points in cMoS.
	To enable efficient tailoring to specific applications during the
	operation phase, the variation points are not implicitly hardcoded
	as traditionally, but are explicitly expressed as models. The use
	of the resulting models is still limited due to a high barrier of
	their implementation. This barrier is sought to be amended by model-driven
	engineering (MDE): models of the variation points are computerized
	and their implementation is automatically generated. The end result
	is a model-driven and mostly programming free cMoS system adaptable
	to new M&S applications through abstract modeling of the variation
	points. The proposed framework and model-driven construction of a
	cMoS system are demonstrated. The system customization has been verified
	for a number of domains: Data Flow Diagrams (DFD), Discrete Event
	System Specification (DEVS), Process Interaction (PI) and Dynamic
	Traffic Routing (DTR). A demonstration of the latter is included
	in this paper. Generic cMoS functionality, such as modeling, collaborative
	sharing of conceptual models, online simulation and management of
	shared simulation resources is demonstrated as well.},
  doi = {DOI: 10.1016/j.simpat.2008.10.004},
  issn = {1569-190X},
  keywords = {Modeling and simulation (M&S)},
  review = {[Proposta]
	
	Propõe um framework collaborative Modeling and online Simulation (cMoS)
	como base para aplicaçãos web baseadas em M&S.
	
	
	[Motivação]
	
	Crescimento da complexidade de sistemas demandam por ambientes colaborativos
	e multi-paradigmas.
	
	
	[Como os ambientes colaborativos são aplicados]
	
	Para o desenvolvimento de modelagem e simulação M&S.
	
	Apesar da colaboração estar relacionada com outro tipo de modelagem
	(M&S) que não o mdd, se trata de um trabalho que pretende melhorar
	o desevolvimento de modelos e simulação de forma colaborativa
	
	
	[Relacionamento com MDD]
	
	No caso, o mdd é usado para reduzir a complexidade e aumentar a eficiência
	de implementar modelos no framework cMOS.},
  timestamp = {2010.02.19},
  url = {http://www.sciencedirect.com/science/article/B6X3C-4TTMJVD-3/2/70980d0fe1e9feb5c42f0bf528422390}
}

@ARTICLE{Liggesmeyer2009,
  author = {Peter Liggesmeyer and Mario Trapp},
  title = {Trends in Embedded Software Engineering},
  journal = {IEEE Software},
  year = {2009},
  volume = {26},
  pages = {19-25},
  address = {Los Alamitos, CA, USA},
  contributions = {Embedded Software: fala do diferencial, em especial das limitações
	(Requisitos de recursos, Diversidade de sistemas embarcados), de
	sistemas embarcados.},
  doi = {http://doi.ieeecomputersociety.org/10.1109/MS.2009.80},
  file = {:home/david/Dropbox/PROJETO DE MESTRADO/Artigos/SEC/Trends in Embedded Software Engineering - Liggesmeyer2009.pdf:PDF;:home/david/Dropbox/PROJETO DE MESTRADO/Artigos/SEC/Trends in Embedded Software Engineering - Liggesmeyer2009.okular:PDF},
  issn = {0740-7459},
  keywords = {embedded systems development, model-driven development, embedded software,
	quality assurance, safety-critical systems},
  problem/context = {Here, we identify specific characteristics of embedded software, describe
	the paradigm of model-driven software engineering, and describe challenges
	and solutions to assure the quality of embedded software.},
  publisher = {IEEE Computer Society},
  relevance = {5},
  review = {Os sistemas de TI possuem plataformas de desenvolvimento bastante
	maduras que proveêm toda infra-estrutura para arquiteturas orientada
	a serviço, sistemas distribuídos, recuperação de erros e segurança,
	além de uma série de outros serviços que estes ambientes de desenvolvimento
	oferecem. Entretanto, tal abordagem não ocorre no domínio de sistemas
	embarcados. ->Identificando uma deficiência de SE. Bendix2009 identifica
	uma deficiência assim em relação a plataformas sobre MDD.
	
	
	
	
	- Nos últimos 20 anos, o impacto dos software nas funcionalidades
	de sistemas embarcados, bem como sobre o potencial de inovação de
	novos produtos, tem crescido rapidamente. Isto levou a um enorme
	crescimento na complexidade de softwares, shorter innovation cycle
	times (ciclos de vida de inovação mais curtos ou menores tempos de
	ciclo de inovação) e a uma procura sempre crescente por requisitos
	extrafuncionais, como segurança, confiabilidade e rapidez, a custos
	acessíveis.
	
	
	- Com o aumento da complexidade dos sistemas embarcados e a exigência
	cada vez maior por qualidade, o papel da engenharia de software tem
	se tornado cada vez mais importante.
	
	
	- O desenvolvimento de software está mudando da programação manual
	para o MDD
	
	
	- Desenvolvedores de sistemas de TI modernos usam plataformas padronizadas
	que fornecem a infra-estrutura básica para arquiteturas orientadas
	a serviços, sistemas distribuidos, recuperação de erros e confiabilidade
	
	- Contudo, tal abordagem não se encaixa no dominio de sistemas embarcados.
	Requisitos oriundos de custo, energia, restrições de tamanho ou peso,
	demandam pelo uso eficiente de recursos de hardware disponiveis.
	
	
	- A diversidade de sistemas embarcados também impede a criação de
	uma plataforma única especializada.
	
	
	- Obviously, no single embedded system exists. Moreover, embedded
	software is rarely a stand-alone product; rather, it?s a single element
	in a product consisting of mechanics, electrics and electronics,
	and software. Embedded system development always focuses on the product,
	so it must consider various constraints. For one, many embedded systems
	are mass-produced products with tight cost restrictions. Moreover,
	embedded systems developers must consider resource limitations and
	extreme environmental conditions such as heat, humidity, or radiation.
	
	- To meet these requirements, developers ofen create a product-specific
	hardware platform. Consequently, embedded software must be taiored
	to heterogeneous hardware platforms ...
	
	- The need to create specialized hardware and software platforms is
	a key difference between IT systems and embedded systems. 
	
	
	- Requisitos extrafuncionais contribuem para a difícil tarefa de criar
	uma plataforma única de desenvolvimento. Tais requisitos são mais
	importantes em sistemas embarcados que em sistemas de ti.
	
	
	- Além disso, recursos de custo e outras limitações costumam criar
	conflitos com os requisitos extrafuncionais, como requisito de tempo
	real. Além do que os desenvolvedores precisam de um extenso conhecimento
	do domínio. 
	
	
	- Gerenciar o rápido crescimento da complexidade do desenvolvimento
	de sistemas embarcados é um dos mais importantes desafios para aumentar
	a qualidade dos produtos, reduzir o tempo ao mercado e reduzir custos
	de desenvolvimento. MDD é uma abordagem promissora que tem emergido
	ao longo das últimas décadas. Em vez de codificar o software usando
	linguagens de programação, desenvolvedores modelam sistemas de software
	usando intuitivas e mais expressivas notações gráficas, das quais
	fornecem um aumento no nível de abstração maior do que nas linguagens
	de programação. Nesta abordagem, geradores criam automaticamente
	o código implementando as funcionalidades dos sistema. Para gerenciar
	o crescimento da complexidade de sistemas embarcados, a modelagem
	irá provavelmente substituir a codificação manual no nível de desenvolvimento
	de aplicações, assim como as linguagens de programação de alto nível
	substituíram a linguagem assembly.
	
	
	- MDD em sistemas embarcados começaram muito antes, antes da UML e
	da MDA serem padronizadas. Um exemplo disso são as linguagens de
	modelagem matlab/simulink e labview. Com essas ferramentas, desenvolvedores
	podem especificar sistemas embarcados completos usando modelos de
	alto níveis.
	
	
	- MDD é baseado em linguagens de propósitos gerais e geradores de
	código para aplicações de diferentes domínios.
	
	
	- Domain specific modeling permitem os desenvolvedores usarem conceitos
	específicos de domínio, por isso fornecem uma linguagem de modelagem
	ainda mais intuitiva e integram mais ainda o know-how dos desenvolvedores
	de software e as otimizações especificas de aplicações dentro dos
	geradores de código.
	
	
	- Como exemplo: um desenho de um especialista de domínio no visio
	é na verdade um modelo com uma sintaxe e semântica clara que permitem
	a geração de código baseadas nesta especificação.
	
	
	- Embora uma modelagem especifica de domínio possa simplificar a especificação
	de um sistema, a linguagem de modelagem é limitada a classes especifica
	de problemas
	
	
	- Um desafio é portanto definir sistematicamente como garantir segurança
	no contexto do mdd.
	
	- Temos também que esclarecer como diferentes demandas serao aplicadas
	a abordagem mdd. Conceitos de mdd podem ser benéficos na engenharia
	de segurança. Particularmente para a engenharia de segurança de sistemas
	criticos.
	
	
	- The rapid progress of systematic software engineering technologies
	will therefore be a key factor in the successful future development
	of even more-complex embedded systems.
	
	
	Os sistemas de TI possuem plataformas de desenvolvimento bastante
	maduras que proveêm toda infra-estrutura para arquiteturas orientada
	a serviço, sistemas distribuídos, recuperação de erros e segurança,
	além de uma série de outros serviços que estes ambientes de desenvolvimento
	oferecem. Entretanto, tal abordagem não ocorre no domínio de sistemas
	embarcados. ->Identificando uma deficiência de SE. Bendix2009 identifica
	uma deficiência assim em relação a plataformas sobre MDD.
	
	
	-------------------------------------------------------------------------------
	
	
	
	- Over the last 20 years, software’s impact on embedded system functionality,
	as well as on the innovation and differentiation potential of new
	products, has grown rapidly. This has led to an enormous increase
	in software complexity, shorter innovation cycle times, and an ever-growing
	demand for extrafunctional requirements—software safety, reliability,
	and timeliness, for example—at affordable costs.
	
	
	- With embedded software’s increasing complexity and quality demands,
	however, software engineering’s role is becoming more important.
	
	
	- Software development is shifting from manual programming to model-driven
	development (MDD).
	
	
	- Developers of modern IT systems use standardized platforms that
	provide the basic infrastructure for service-oriented architectures,
	distributed systems, error recovery, and reliability. 
	
	
	- However, such an approach doesn’t fit the embedded systems domain.
	Resource requirements originating from cost, energy, size, or weight
	constraints demand the efficient use of available hardware resources.
	So, heavyweight abstraction layers, platforms, and virtualization
	techniques that require many resources for mapping high-level platforms
	to concrete hardware devices aren’t feasible.
	
	
	- The diversity of embedded systems also prevents the creation of
	a single specialized platform.
	
	
	- Obviously, no single embedded system exists. Moreover, embedded
	software is rarely a stand-alone product; rather, it’s a single element
	in a product consisting of mechanics, electrics and electronics,
	and software. Embedded system development always focuses on the product,
	so it must consider various constraints. For one, many embedded systems
	are mass-produced products with tight cost restrictions. Moreover,
	embedded systems developers must consider resource limitations and
	extreme environmental conditions such as heat, humidity, or radiation.
	
	
	- To meet these requirements, developers ofen create a product-specific
	hardware platform. Consequently, embedded software must be taiored
	to heterogeneous hardware platforms ...
	
	
	- The need to create specialized hardware and software platforms is
	a key difference between IT systems and embedded systems. 
	
	
	- Extrafunctional requirements contribute to these difficulties. Such
	requirements are far more important in embedded systems than in IT
	systems ...
	
	
	- Moreover, resource, cost, and other limitationoften conflict with
	extrafunctional requirement(such as real-time requirements).
	
	- In addition, embedded systems developers require extensive domain
	knowledge.
	
	
	- Managing the rapidly increasing complexity of embedded software
	development is one of the most important challenges for increasing
	product qualty, reducing time to market, and reducing development
	cost. 
	
	- MDD is one of the promising approaches that have emerged over the
	last decade. Instead of directly coding software using programming
	languages, developers model software systems using intuitive, more
	expressive, graphical notations, which provide a higher level of
	abstraction than native programming languages. In this approach,
	generators automatically create the code implementing the system
	functionalities. To manage embedded systems’ growing complexity,
	modeling will likely replace manual coding for application-level
	development—just as high-level programming languages have almost
	completely replaced assembly language.
	
	
	- MDD of embedded systems started much earlier, before UML and MDA
	were standardized. Therefore, its main drivers have been modeling
	tools implementing vendor-specific languages (for example, Matlab/
	
	Simulink and LabView). Using these tools, developers can completely
	specify embedded software systems using high-level models. 
	
	
	- MDD is based on general-purpose languages and code generators for
	different application domains. 
	
	
	- Domain-specific modeling lets developers use domain-specific concepts,
	so it provides even more-intuitive modeling languages and integrates
	more software developer know-how and application-specific optimizations
	into the code generators.
	
	
	
	- ...like a domain expert’s Visio drawing, it’s actually a formal
	model with a clear syntax and semantics, enabling code generation
	based on this specification.
	
	
	- Although domain-specific modeling simplifies system specification,
	the modeling language is limited to a specific class of problems.
	
	
	- A challenge is therefore to systematically define how to ensure
	safety in the model-driven-engineering context—and not only through
	verification and validation.
	
	- We must also clarify how different demands will be applied to MDD
	approaches. MDD concepts could be beneficial in safety engineering.
	Particularly for engineering safety-critical systems, isolated concepts
	available in research must evolve into standard approaches accepted
	by certification bodies.
	
	
	- The rapid progress of systematic software engineering technologies
	will therefore be a key factor in the successful future development
	of even more-complex embedded systems.},
  theme = {SE},
  timestamp = {2010.01.30}
}

@ARTICLE{Louridas2006,
  author = {Louridas, P.},
  title = {Using wikis in software development},
  journal = {Software, IEEE},
  year = {2006},
  volume = {23},
  pages = { 88-91},
  number = {2},
  month = {March-April},
  doi = {10.1109/MS.2006.62},
  issn = {0740-7459},
  keywords = { Web sites, public domain software, software engineering Web sites,
	open source software, software development, wiki engines},
  timestamp = {2010.02.16}
}

@PHDTHESIS{Lucredio2009,
  author = {Daniel Lucrédio},
  title = {Uma Abordagem Orientada a Modelos para Reutilização de Software},
  school = {Universidade de São Paulo, Instituto de Ciências Matemáticas e de
	Computação},
  year = {2009},
  owner = {david},
  timestamp = {2010.02.04}
}

@INPROCEEDINGS{Lucredio:2006:wdbc,
  author = {Lucrédio, Daniel and Fortes, Renata Pontin de Mattos and Almeida,
	Eduardo Santana de and Meira, Silvio Romero de Lemos},
  title = {{The Draco Approach Revisited: Model-Driven Software Reuse}},
  booktitle = {VI WDBC - Workshop de Desenvolvimento Baseado em Componentes},
  year = {2006},
  address = {Recife - PE - Brazil}
}

@ARTICLE{Lucredio2008,
  author = {Lucrédio, D. and Fortes R.P.M. and Whittle, J.b},
  title = {MOOGLE: A model search engine},
  journal = {Lecture Notes in Computer Science},
  year = {2008},
  volume = {5301 LNCS},
  pages = {296-310},
  abbrev_source_title = {Lect. Notes Comput. Sci.},
  abstract = {Models are becoming increasingly important in the software process.
	As a consequence, the number of models being used is increasing,
	and so is the need for efficient mechanisms to search them. Various
	existing search engines could be used for this purpose, but they
	lack features to properly search models, mainly because they are
	strongly focused on text-based search. This paper presents Moogle,
	a model search engine that uses metamodeling information to create
	richer search indexes and to allow more complex queries to be performed.
	The paper also presents the results of an evaluation of Moogle, which
	showed that the metamodel information improves the accuracy of the
	search. Â© 2008 Springer-Verlag Berlin Heidelberg.},
  address = {Toulouse},
  affiliation = {Institute of Mathematical and Computer Science, USP, Av. Trabalhador
	SÃ£o-Carlense - 400 Centro, SÃ£o Carlos, SP CEP 13560-970, Brazil;
	Computing Department, InfoLab21, Lancaster University, Lancaster
	LA1 4WA, United Kingdom},
  author_keywords = {Model search; Model-driven development; Software reuse},
  correspondence_address = {LucrÃ©dio, D.; Institute of Mathematical and Computer Science, USP,
	Av. Trabalhador SÃ£o-Carlense - 400 Centro, SÃ£o Carlos, SP CEP 13560-970,
	Brazil; email: lucredio@icmc.usp.br},
  document_type = {Conference Paper},
  doi = {10.1007/978-3-540-87875-9_22},
  isbn = {3540878742; 9783540878742},
  issn = {03029743},
  keywords = {Computer software; Computer software reusability; Information retrieval;
	Internet; Linguistics; Search engines; Telecommunication networks;
	World Wide Web, Complex queries; Metamodeling; Search models; Software
	processes; Software reuse, Models},
  language = {English},
  source = {Scopus},
  sponsors = {ACM Special Interest Group on Software Engineering; IEEE Computer
	Society},
  timestamp = {2010.02.17},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-56649094213&partnerID=40&md5=a12d1043d6a999037a7269eaa2682bea}
}

@INPROCEEDINGS{Majchrzak2006,
  author = {Majchrzak, Ann and Wagner, Christian and Yates, Dave},
  title = {Corporate wiki users: results of a survey},
  booktitle = {WikiSym '06: Proceedings of the 2006 international symposium on Wikis},
  year = {2006},
  pages = {99--104},
  address = {New York, NY, USA},
  publisher = {ACM},
  doi = {http://doi.acm.org/10.1145/1149453.1149472},
  isbn = {1-59593-413-8},
  location = {Odense, Denmark},
  timestamp = {2010.02.16}
}

@ARTICLE{Martinez2009,
  author = {Mart\'{\i}nez, Jes\'{u}s and Merino, Pedro and Salmer\'{o}n, Alberto
	and Malpartida, Francisco},
  title = {UML-Based Model-Driven Development for HSDPA Design},
  journal = {IEEE Softw.},
  year = {2009},
  volume = {26},
  pages = {26--33},
  number = {3},
  abstract = {This article examines using model-driven development (MDD) with UML
	for communication protocols. The authors believe this approach is
	essential for reducing the costs of developing, maintaining, and
	evolving complex software systems. However, is this statement valid
	for communication protocol software? Such software's stringent performance
	and robustness requirements are critical for embedded devices in
	modern mobile and cellular networks. To compare UML-based MDD with
	a code-centric approach, the authors developed two versions of a
	fully functional High-Speed Downlink Packet Access (HSDPA) prototype.
	Experiments show that the development process was easier with UML-based
	MDD than with the code-centric approach, without sacrificing performance.},
  address = {Los Alamitos, CA, USA},
  doi = {http://dx.doi.org/10.1109/MS.2009.81},
  file = {:home/david/Dropbox/PROJETO DE MESTRADO/Artigos/SEC/UML-Based Model-Driven Development for HSDPA Design - Martinez2009.pdf:PDF;:home/david/Dropbox/PROJETO DE MESTRADO/Artigos/SEC/UML-Based Model-Driven Development for HSDPA Design - Martinez2009.okular:PDF},
  issn = {0740-7459},
  keywords = {model-driven development, communication protocol, UML, code-centric
	software, High-Speed Downlink Packet Access, HSDPA, Adaptive Communication
	Environment, ACE, Rhapsody},
  publisher = {IEEE Computer Society Press},
  review = {- Contudo, nós acreditamos que o MDD com UML é essencial para reduzir
	custos, manter e evoluir sistemas complexos de software.
	
	- O principal incoveniente de usar uma metodologia centrada no código
	é a dificuldade de manter e extender o sistema.
	
	- Uma metodologia alternativa é o MDD, o qual envolve linguagens visuais
	de modelagem e ferramentas de apoio.
	
	- Como esperado, o processo de desenvolvimento foi muito mais fácil
	usando UML baseado em MDD do que com a abordagem centrada no código,
	em termos de esforço requerido para o design, debug, geração de código
	e teste do sistema.
	
	- O processo de desenvolvimeto de ambas abordagens diferem significativamente.
	Modelos visuais são normalmente muito mais fáceis de se entender
	do que o código fonte.
	
	- Os resultados foram similares para ambas implementações (mesmo com
	alguns resultados melhores no caso do Rhapsody), validando assim
	a abordagem MDD, com todas as suas vantagens de modelagem visual
	e de teste, ao contrário da implementação de código manual.
	
	- Sistemas de grande escala, desenvolvidos por vários engenheiros,
	agora estão usando abordagens orientada a modelos, a qual foi aplicada
	com sucesso neste trabalho, para construir um protótipo em menor
	escala, e nós esperamos que nossos resultados sejam validados. Não
	obstante, todo o trabalho existente nas bibliotecas e nas ferramentas
	desenvolvidas para as metodologias tradicionais podem ser reusadas
	no contexto do MDD, além de podem extrair modelos existentes em sistemas
	de código puro.
	
	
	
	
	- However, we believe that model-driven development (MDD)1,2 with
	UML3 is essential for reducing the costs of developing, maintaining,
	and evolving complex software systems.
	
	- A major drawback of using any code-centric methodology is the difficulty
	of maintaining and extending it.
	
	- An alternative methodology is MDD, which involves using visual-modeling
	languages and supporting tools. 
	
	- As expected, the development process was easier with UML-based MDD
	than with the code-centric approach, in terms of the effort required
	to design, debug, generate code for, and test the system. 
	
	- The development process for both approaches differed significantly.
	Visual models are usually easier to understand than straight source
	code.
	
	- The results were similar for both implementations (even with some
	better results in the Rhapsody case), thus validating the MDD approach,
	with all its advantages for visual modeling and testing, against
	a manually coded implementation.
	
	- A full-scale system developed by several engineers is now using
	the MDD approach that we successfully applied to build a small-scale
	prototype, and we hope our findings will be validated. Nevertheless,
	all the existing work done on libraries and tools for more traditional
	methodologies can be reused in the context of MDD. In addition, we
	can extract models of existing, pure-code systems.},
  theme = {SE},
  timestamp = {2010.02.01}
}

@INPROCEEDINGS{McQuay2004,
  author = {McQuay, W.K.},
  title = {Distributed Collaborative Environments for Systems Engineering},
  booktitle = {Digital Avionics Systems Conference, 2004. DASC 04. The 23rd},
  year = {2004},
  volume = {2},
  pages = { 9.D.3-91-10 Vol.2},
  month = {Oct.},
  abstract = {Distributed collaboration is an emerging technology for the 21‘‘ century
	that will
	
	significantly change how business is conducted in the defense and
	commercial sectors. Collaboration
	
	involves two or more geographically dispersed individuals working
	together to create a “product”
	
	by sharing and exchanging data, information, and knowledge. A product
	is defined broadly to
	
	include, for example, writing a report, creating software, designing
	hardware, or implementing
	
	robust systems engineering processes in an organization. Collaborative
	environments provide
	
	the framework and integrate models, simulations, domain specific tools,
	and virtual test beds to
	
	facilitate collaboration between the multiple disciplines needed in
	the enterprise. The Air Force
	
	Research Laboratory (AFRL) is conducting a leading edge program in
	developing distributed
	
	collaborative technologies targeted to the Air Force’s implementation
	of systems engineering for
	
	simulation-aided acquisition and test process and capability-based
	planning. The research is focusing
	
	on the open systems agent-based framework, product and process modeling,
	structural
	
	architecture, and the integration technologies - the glue to integrate
	the software components. In past
	
	four years, two live assessment events have been conducted to demonstrate
	the technology in support
	
	of Air Force Agile Acquisition that included capabilities for system
	engineering. The AFRL
	
	Collaborative Environment concept will foster a major cultural change
	in how the acquisition,
	
	training, and operational communities conduct business},
  issn = { },
  keywords = { aerospace computing, groupware, open systems, systems engineering
	Air Force Research Laboratory, air force agile acquisition, capability
	based planning, data exchange, distributed collaborative environments,
	distributed collaborative technology, information exchange, knowledge
	exchange, open systems agent based framework, process modeling, product
	modeling, simulation aided acquisition, software components, structural
	architecture, systems engineering},
  review = {Definie o que é colaboração. O que são ambientes colaborativos.},
  timestamp = {2010.02.16}
}

@BOOK{Mehta2009,
  title = {Choosing an Open Source CMS: Beginner's Guide},
  publisher = {Packt Publishing},
  year = {2009},
  author = {Nirav Mehta},
  month = {4},
  isbn = {9781847196224},
  price = {$39.99},
  review = {Os principais recursos de CMS de propósito geral, segundo mehta, são:
	
	criar e gerenciar conteúdo de seções ou hierarquia;
	
	criar paginas e facilmente adicionar texto ou imagem
	
	reorganizar ou editar um conteúdo já publicado a qualquer momento
	
	 Automatic linking and content publishing
	
	permitir que multiplos usuários possam administrar ou gerenciar conteúdo
	
	
	são alguns exemplos: Joomla!: http://www.joomla.org/, Drupal: http://www.drupal.org/,
	Plone: http://plone.org/
	
	
	Wikis são usadas tanto em redes publicas quanto em privadas e podem
	ser customizxadas para atendar as necessidades de quem for usar.
	tem-se como principais recursos:
	
	-Facilmente criar e editar paginas com apenas um browser
	
	-simples Sintaxe de marcação 
	
	- Criação de link simples ou automatico, mesmo quando a paguna de
	destino ainda nao existe
	
	- Histórico completo das revisões, com possibilidade de reverter a
	qualquer momento
	
	- podem restringir acesso por meio de loggin
	
	Wikis sao colaborativas por natureza e a quliade do conteudo melhora
	a medidade que as pessoas contribuem.
	
	
	CMSs colaborativos:
	
	Um CMS colaborativo é geralmente desenvolvido para usuários internos
	de uma organização. Algumas de seus principais recursos são:
	
	- Gerenciamento de usuário
	
	- Gerenciamento de documentos/registros, revisões e comentários
	
	- Workflow e aprovação de processos
	
	- Grupos e espaços para organizar o trabalho
	
	- BLog, forum, wiki e etc, para auxiliar a colaboração
	
	- Acesso ao desktop, APIs e padrões de compilação para atender a integração
	com outros sistemas
	
	- Características específicas de sistema: gerenciamento de contatos,
	base de conhecimento, gestao de projeto e etc.
	
	
	São exemplos de cms colaborativos ou intranet cms: Alfresco?http://www.alfresco.com/
	
	Nuxeo?http://www.nuxeo.com/
	
	Jahia?http://www.jahia.com/
	
	
	Intranets cms podem reduzir a quantidade de e-mail e a sobrecarga
	de comunicação, acelerando processos. Eles ajudam a manter a maioria
	das informações em um único lugar. Como possibilidades de uso de
	cmss intranets, tem-se:
	
	- Manter todas as normas, políticas, formulários e documentos em um
	único lugar;
	
	- Usar workflows para gerenciar o design ou aprovações de documentações
	
	- Gerenciar alterações aos documentos por meio de controle de revisão
	
	- Integrar partes terceirizadas e ligar a uma folha de pagamento ou
	a um sistema de gerenciamento de projeto
	
	- Gerenciar campanhas de marketing centralizando todaas as informações,
	documentos, relatórios...
	
	- Configurar uma base de conhecimento usando uma wiki ou um gerenciador
	de documentos
	
	
	Coisas em comum: embora tenham vários tipos de cms, todos tem algumas
	caracteristicas em comum. Eles essencialmente permitem voce adicionar
	e gerenciar algum tipo de conteuudo - texto, imagem, arquivos. Sao
	caracateristicas comuns em muitos cms:
	
	- Editor WYSIWYG: um editor What You See Is What You Get permite o
	usuário inserir um texto e formatá-lo. Alguns outros editores ainda
	permitem inserir imagens ou outros tipos de mídia;
	
	- Categorias e hierarquia de conteúdo: seções, categorias ou níveis
	para organizar o conteúdo são muito comuns;
	
	- Ferramentas de pesquisa otimizadas: URLs e meta tags são suportadas
	por ferramentas de procura;
	
	- Marcação: criar marcações com palavras-chave e depois exibir em
	uma lista
	
	- Diferentes níveis de usuários: a maioria dos cmss permitem multiplos
	usuários par gerenciar conteudo. Muitos ainda tem funções e niveis
	de acessos para controlar o que cada usuário pode fazer
	
	- Suporte a Plug-in: estender os recursos do núcleo (recursos base)
	do cms adicionando plugins ou extensões.
	
	- Temas e skins: personalizar a aparencia com temas
	
	
	
	Arquitetura dos CMS:
	
	CMSs baseados na web tem uma arquitetura simples de 3 camadas, assim
	como outra qualquer aplicação web: browser->web server->database
	server. Entretanto, internamente, diferentes cms podem ter diferentes
	designs.
	
	Arquitetura do Joomla\footnote{http://docs.joomla.org/Framework}
	
	
	
	Drupal\footnote{http://drupal.org/getting-started/before/overview}
	
	
	A figura A e B (joomla e drupal) ilustram a arquitetura desses dois
	cms bastante usados, mas não será esmiuçado os detalhes de cada um.
	
	
	General-Purpose CMSs: Joomla, Drupal, and so on
	
	Wikis for easy collaboration: MediaWiki, DokuWiki, and so on
	
	Intranet and Enterprise CMSs: Alfresco, Nuxeo, and so on
	
	
	O que torna as wikis tao especiais?
	
	Não é apenas a facilidade de contribuição que fazem as wikis especiais.
	Ela tambem se destaca por outras formas, como:
	
	- Empenho na criação de links e conteúdos; cria links mesmo sem conteúdo
	
	- Controle de acesso total - de usuários e páginas
	
	- Muitas wikis não precisam de banco de dados, o que as deixa portáveis
	
	- Controle de revisão: rever as mudanças e reverter
	
	- Categorizar paginas para melhor organizacao
	
	- Criação automática de uma tabela de conteúdo (indice)
	
	- Amplos recursos de pesquisa},
  timestamp = {2010.02.11},
  totalpages = {340},
  url = {http://amazon.com/o/ASIN/1847196225/}
}

@INPROCEEDINGS{Meijler2005,
  author = {T.D. Meijler},
  title = {Requirements for an Integrated Domain Specific Modeling, Modeling
	Language Development, and Execution Environment},
  booktitle = {in Proceedings of NWUML'2005: The 3rd Nordic Workshop on UML and
	Software Modeling},
  year = {2005},
  abstract = {Domain Specific Modeling Languages (DSMLs) offer powerful expressivity
	within clearly constrained domains. By using DSMLs domain experts
	can describe solutions in terms of models that make sense to them,
	and these models can be mapped to system realizations. Thus, DSMLs
	can move software development in these domains closer to the domain
	expert and make it more efficient. Large-scale use of DSMLs for realizing
	enterprise applications requires an extended infrastructure for developing
	and using these languages. In fact it requires an integrated modeling
	and execution environment in order to allow run-time adaptation of
	models and rapid incremental extension of the applications. In this
	paper we shall give an overview of requirements for an infrastructure
	that both supports developing and using DSMLs as well as executing
	the corresponding models as necessary for the Enterprise Application
	domain.},
  file = {:C\:\\Documents and Settings\\david\\Meus documentos\\My Dropbox\\PROJETO DE MESTRADO\\Artigos\\Requirements for an Integrated Domain Specific Modeling, Modeling Language Development and Execution Environment - Meijler2005.pdf:PDF},
  owner = {david},
  review = {Model-driven development (MDD) raises the level of abstraction for
	software development by expressing what a computer should do by means
	of (design-level) models that hide technical details. In MDD software
	applications are derived from models either through code generation
	or through interpretation. Applying a domain specific modeling language
	(DSML) instead of a generic modeling language such as UML promises
	to bring MDD even closer to the domain expert. DSMLs can make software
	development in specific domains more efficient since they close the
	gap between the expert and the software implementation. 
	
	
	Domain Specific Modeling Languages and their corresponding modeling
	environments –so-called Domain Specific Modeling Environments DSMEs–
	have already been widely used in industry, e.g., for workflow modeling
	[3], for modeling of chemical plants [12] and banking [5] etc [9].},
  situation = {Não muito a ver, mas define bem DSML em MDD},
  theme = {DSML},
  timestamp = {2010.01.24}
}

@ARTICLE{Mellor2003,
  author = {Stephen J. Mellor and Anthony N. Clark and Takao Futagami},
  title = {Guest Editors' Introduction: Model-Driven Development},
  journal = {IEEE Software},
  year = {2003},
  volume = {20},
  pages = {14-18},
  address = {Los Alamitos, CA, USA},
  doi = {http://doi.ieeecomputersociety.org/10.1109/MS.2003.1231145},
  issn = {0740-7459},
  publisher = {IEEE Computer Society},
  review = {Model-driven development is simply the notion
	
	that we can construct a model of a system that
	
	we can then transform into the real thing.},
  timestamp = {2010.02.04}
}

@INPROCEEDINGS{Muthig2002,
  author = {Dirk Muthig and Colin Atkinson},
  title = {Model-Driven Product Line Architectures},
  booktitle = {Software Product Lines},
  year = {2002},
  volume = {2379},
  series = {Lecture Notes in Computer Science},
  pages = {79--90},
  publisher = {Springer Berlin / Heidelberg},
  abstract = {It has long been recognized that successful product line engineering
	revolves around the creation of a coherent and flexible product line
	architecture that consolidates the common parts of a product family
	for reuse and captures the variant parts for simple adaptation. However,
	it has been less clear what form such architectures should take and
	how they should be represented. One promising approach is offered
	by the new Model-Driven Architecture (MDA) paradigm of the Object
	Management Group (OMG). This paradigm holds that an organizations
	key architectural assets should be represented in an abstract platform-independent
	way, in terms of Unified Modeling Language (UML) models, and thereby
	be shielded from the idiosyncrasies and volatility of specific implementation
	technologies. In this paper, we discuss the opportunities and challenges
	involved in using the MDA paradigm for product line engineering and
	explain how model-driven, product line architectures can be developed,
	maintained and applied. After first outlining the core concepts of
	product line engineering and the ad hoc strategies currently used
	to support it, the paper provides a detailed metamodel of the information
	that needs to be stored within a product line architecture.},
  doi = {10.1007/3-540-45652-X_8},
  isbn = {978-3-540-43985-1},
  issn = {0302-9743 (Print) 1611-3349 (Online)},
  subject_collection = {Computer Science},
  timestamp = {2010.02.17},
  url = {http://www.springerlink.com/content/410le2p9wwcjpt43/}
}

@INPROCEEDINGS{Nascimento2007,
  author = {do Nascimento, Francisco Assis M. and Oliveira, Marcio F. S. and
	Wagner, Flavio Rech},
  title = {ModES: Embedded Systems Design Methodology and Tools based on MDE},
  booktitle = {Model-Based Methodologies for Pervasive and Embedded Software, 2007.
	MOMPES '07. Fourth International Workshop on},
  year = {2007},
  pages = {67-76},
  month = {March},
  abstract = {MDE-based approaches have been proposed as a solution to cope with
	the inefficiency of current design methods. In this context, our
	work defines meta-models for application, capturing functionality
	by means of processes communicating by ports and channels; platform,
	indicating available hardware/software resources; mapping from application
	into platform; and implementation, oriented to code generation and
	hardware synthesis. Differently from other approaches, our mapping
	meta-model does not specify only the allocation of application processes
	into fixed hardware components. Instead, it delimits a design space,
	determining all possible associations between processes and platform
	components. Transformations between meta-models implement the mapping,
	allowing the evaluation of possible implementations during a design
	space exploration process. This exploration is based on accurate
	estimates of the effects of each transformation, without requiring
	costly hardware synthesis and code generation steps. These are performed
	only for the final implementation, after all design decisions have
	been taken. We implemented our approach using the Eclipse Modeling
	Framework (EMF) features, where our meta-models are captured by Ecore
	models and the transformation engine uses the MDDi-QVT plug-in. The
	application on a real case study validates the approach},
  contributions = {tem boas referencias sobre mdd em sistemas embarcados},
  doi = {10.1109/MOMPES.2007.14},
  file = {:home/david/Dropbox/PROJETO DE MESTRADO/Artigos/SEC/ModES\: Embedded Systems Design Methodology and Tools based on MDE - Nascimento2007.pdf:PDF},
  keywords = {formal specification, program compilersEclipse modeling framework,
	Ecore models, MDDi-QVT plug-in, ModES, code generation, embedded
	systems design, hardware synthesis, meta-models, model driven engineering},
  relevance = {4},
  review = {Para lidar com a ineficiência dos métodos atuais de desenvolvimento
	(design), muitos esforços de pesquisa na academia e na indústria
	estão concentrados no desenvolvimento de novas tecnologias, as quais
	deveriam ser capazes de lidar com o crescimento da complexidade do
	processo de desenvolvimento (design) de sistemas embarcados. Abordagens
	baseadas em MDE tem sido propostas como uma metodologia eficiente
	para o design de sistemas embarcados [1][2][12][19].\cite{Nascimento2007}
	-> ver as referencias que esse cara faz!!
	
	
	----------------
	
	
	To cope with the inefficiency of the current design methods, many
	research efforts in the academy and industry are concentrated on
	the development of new methodologies, which should be able to deal
	with the growing complexity of the embedded systems design process.
	Approaches based on MDE (Model Driven Engineering) have been proposed
	as an efficient methodology for embedded systems design [1][2]
	
	[12][19]..
	
	
	There are many recent research efforts on embedded systems design
	based on MDE.}
}

@PHDTHESIS{Neighbors:thesis:1980,
  author = {Neighbors, James M.},
  title = {{Software Construction Using Components}},
  school = {University of California at Irvine},
  year = {1980},
  type = {Ph.D. Thesis}
}

@MISC{xmi2,
  author = {OMG},
  title = {Catalog of OMG Modeling and Metadata Specifications - XML Metadata
	Interchange},
  year = {2010},
  note = {Último acesso: 17/02/2010.},
  owner = {david},
  timestamp = {2010.02.17},
  url = {http://www.omg.org/technology/documents/modeling_spec_catalog.htm#XMI}
}

@MISC{xmi1,
  author = {OMG},
  title = {MDA® Specifications - XML Metadata Interchange (XMI™)},
  year = {2009},
  note = {Último acesso: 17/02/2010.},
  owner = {david},
  timestamp = {2010.02.17},
  url = {http://www.omg.org/mda/specs.htm#XMI}
}

@MANUAL{OMG2003,
  title = {MDA Guide Version 1.0.1},
  author = {OMG},
  organization = {Object Management Group (OMG)},
  month = {June},
  year = {2003},
  note = {Document Number: omg/2003-06-01},
  owner = {david},
  review = {The Object Management Group (OMG) was formed to help reduce complexity,
	lower
	
	costs, and hasten the introduction of new software applications. The
	OMG is
	
	accomplishing this goal through the introduction of the Model Driven
	Architecture
	
	(MDA) architectural framework with supporting detailed specifications.
	These
	
	specifications will lead the industry towards interoperable, reusable,
	portable software
	
	components and data models based on standard models.},
  timestamp = {2010.02.04}
}

@MANUAL{OMG2001,
  title = {Model Driven Architecture (MDA)},
  author = {OMG},
  organization = {OMG},
  month = {July},
  year = {2001},
  note = {Document number ormsc/2001-07-01},
  owner = {david},
  timestamp = {2010.02.04}
}

@INPROCEEDINGS{Pei2009,
  author = {Shujun Pei and Deyun Chen},
  title = {The Implementing of Software Configuration Management Based on CMM},
  booktitle = {Wireless Communications, Networking and Mobile Computing, 2009. WiCom
	'09. 5th International Conference on},
  year = {2009},
  pages = {1-4},
  month = {Sept.},
  abstract = {This paper introduces the design and implementing scheme of SCM that
	one software organization may adopt, discusses the basic concepts
	of SCM, putting forward the implement of configuration management
	based on CMMI and putting the stress on the practices of configuration
	identifier, version control and change control. Next presents a software
	development platform integrated software configuration management
	capabilities. By the introduction of document management and code
	management module, so that the whole process of software development
	can management by them, so that the whole process of software development
	can by management by the configuration management norm, to achieve
	the purpose of improvement the quality efficiency of development.},
  doi = {10.1109/WICOM.2009.5301195},
  file = {:C\:\\Documents and Settings\\david\\Meus documentos\\My Dropbox\\PROJETO DE MESTRADO\\Artigos\\The Implementing of Software Configuration Management Based on CMM - Pei2009.pdf:PDF},
  keywords = {Capability Maturity Model, configuration managementCMMI, capability
	maturity model integration for software, change control, code management,
	configuration identifier, document management, software configuration
	management, software development platform, version control},
  situation = {Stand by},
  theme = {SCM apenas, sem modelos},
  timestamp = {2010.01.22}
}

@INPROCEEDINGS{Rama2006,
  author = {Rama, Jiten and Bishop, Judith},
  title = {A survey and comparison of CSCW groupware applications},
  booktitle = {SAICSIT '06: Proceedings of the 2006 annual research conference of
	the South African institute of computer scientists and information
	technologists on IT research in developing countries},
  year = {2006},
  pages = {198--205},
  address = {, Republic of South Africa},
  publisher = {South African Institute for Computer Scientists and Information Technologists},
  abstract = {Technology plays an ever-increasing role in our everyday lives. We
	would like it to be a help rather than a hurdle in our work, particularly
	in collaborating with others. An emerging problem for both individuals
	and groups is information spread and neglect, where users have the
	same copy of the same work, stored on various conventional devices,
	but no way to keep track of where the most recent version resides.
	One type of computer support collaborative work application, groupware,
	tackles this problem, aiming to assist in joint authoring projects,
	where artifacts such as files, pictures, reports and sound are being
	gathered to form a whole. Such groupware systems - and we survey
	seven of them - vary in terms of their functional, architectural,
	focal, temporal, user involvement and platform dependencies. While
	we found a wide variety of options for each system, there were also
	strong commonalities. All of them work with closed communities or
	groups. There is no public file sharing. All users are aware of all
	other collaborators in the community and all systems focus on collaboration;
	not sharing. The comparison includes our own system Nomad, a framework
	for distributed resource management, with special emphasis placed
	on the accessibility of information stored on detached devices, such
	as personal computers, laptops, PDA's and flash-disks. In the comparison,
	Nomad has advantages of flexibility and temporal independence over
	the other systems, together with low requirements on the user, and
	a high level of mobility and platform independence. The contributions
	of this paper are twofold: we identify and define a specific type
	of CSCW, groupware, together with a set of criteria for evaluating
	such systems; and we survey and classify some of the main systems
	according to the criteria, as well as introducing a custom-designed
	system, Nomad. From these results, a collaborative group of workers
	can more easily select a specific groupware that suits its needs.
	Moreover, designers of new systems will find the commonality factors
	useful, so they can more easily position their own products.},
  doi = {http://doi.acm.org/10.1145/1216262.1216284},
  file = {:home/david/Dropbox/PROJETO DE MESTRADO/Artigos/Colaboração/A Survey and Comparison of CSCW Groupware Applications - Rama2006.pdf:PDF;:C\:\\Documents and Settings\\david\\Meus documentos\\My Dropbox\\PROJETO DE MESTRADO\\Artigos\\Colaboração\\A Survey and Comparison of CSCW Groupware Applications - Rama2006.pdf:PDF},
  isbn = {1-59593-567-3},
  keywords = {CSCW, comparison, groupware, human-computer interaction, survey},
  location = {Somerset West, South Africa},
  objectives/proposal = {Survey de ferramentas de groupware
	
	Propõe uma ferramenta de groupware},
  review = {- CSCW é o estudo de como as pessoas usam a tecnologia, com relação
	ao hardware e software, para trabalharem juntar em tempo e espaço
	compartilhados. [rama apud grudin]
	
	- Celular, email, instant messenger, blog sao ferramentas de cscw
	[rama, apud campbell e nardi]
	
	- Existem duas dimensões em CSCW: tempo e espaço. Falar dos 4 quadrantes.
	
	- Embora seja difícil de definir CSCW e groupware, e não existe uma
	definição que satisfaça a todos, existem conferencias individuais
	para cada um. O termo CSCW é usado para definir a área da pesquisa
	e groupware .... grudin
	
	- Groupware é considerado uma tecnologia de apoio, seja hardware,
	software, serviços e/ou técnicas, as quais possibilitam as pessoas
	trabalharem em grupos. CSCW, por outro lado, foca no estudo de ferramentas
	e técnicas para grouware, bem como seus impactos sociais, organizacionais
	e psicológicos.
	
	- Groupware, também conhecido como software colaborativo {bannon 1991},
	permite que muitos usuários trabalhem simultaneamente no mesmo projeto.
	Considerando que um ``single user system'' foca no trabalho individual,
	groupware foca no grupo. Quais as vantagens que um groupware propiciam
	em comparação com um single user system? Quando se trabalha em um
	projeto onde a comunicação é essencial entre os colaboradores, o
	groupware facilita a comunicação mais rápida e limpa e permite a
	comunicação onde ela não seria possível. Ele visa permitir múltiplas
	perspectivas, especialidades e assistências não solução de problemas
	pelo grupo.Sua intenção é economizar tempo e gasto coordenando o
	trabalho do grupo. Por outro lado, groupware é mais complexo de se
	desenvolver e manter que um sistema de single user system.
	
	
	-> Critérios de Comparação: Functional criteria; Architectural criteria;
	Focal criteria; Temporal criteria; Platform criteria; User involvement
	criteria
	
	
	---------------------------------------------
	
	
	Ver referências marcadas no artigo
	
	Define diversos critérios para se comparar aplicações groupwares.
	Muito bom para eu caracterizar a minha ferramente e para comparar
	com as do artigo.[
	
	
	- Computer supported cooperative work (CSCW) is the study of how people
	use technology, with relation to hardware and software, to work together
	in shared time and space. CSCW began as an effort by technologists
	to learn from
	
	anyone who could help them better understand group activity and how
	technology could be used to support people in their work. These specialists
	spanned many areas of research, including economists, social psychologists,
	
	anthropologists, organizational theorists and educators [Grudin 1994].
	
	
	- Both email and cellular phones are tools of CSCW, as is instant
	messaging [Campbell 2004]. A more recent tool which has made an impact
	in the social arena of CSCW is blogging [Nardi 2004]. 
	
	
	- There are two dimensions to CSCW - space and time. 1st->4th Quadrant
	
	
	- Although CSCW and groupware are difficult to define, and no single
	definition satisfies everyone, there are individual conferences held
	for each. The term CSCW is used to define the research area and groupware
	defines the
	
	technology [Grundin 1994]. It is common to differentiate between these
	terms so that groupware is technologically focused and narrows the
	social forms of cooperation that CSCW spans [Bannon 1991]. For the
	purposes on this paper,
	
	we make the same distinction between CSCW and groupware. Groupware
	is considered to be the enabling technology, be it hardware, software,
	services and/or techniques, which allow people to work in groups.
	CSCW, on the other hand, focuses on the study of tools and techniques
	of groupware as well as their psychological, social, and organizational
	impact. We now discuss groupware, and aspects relating to groupware.
	
	
	- Groupware, also known as collaborative software [Bannon 1991], allows
	many concurrent users to work on the same project. Whereas a single
	user system focuses on the individual, groupware focuses on the group.
	What advantages does a groupware system offer when compared to a
	single user system? When working on a project where communication
	is essential between collaborators, groupware facilitates communication
	faster and clearer, and enables communication where it would not
	otherwise be possible. It aims to allow multiple perspectives, expertise
	and assistance with group problem solving. It aims to save time and
	cost in coordinating group work. With this in mind, groupware is
	far more complex to design and maintain than a single user system.
	
	
	
	- factors contributing to success and failure are hard to quantify
	
	
	
	- Critérios de Comparação: Functional criteria; Architectural criteria;
	Focal criteria; Temporal criteria; Platform criteria; User involvement
	criteria
	
	
	- All systems focus on collaboration; not sharing. This means they
	work with dynamic documents (documents that change over time) rather
	than sharing which focuses on moving static documents around.},
  situation = {OK},
  theme = {Colaboração},
  timestamp = {2010.01.26}
}

@UNPUBLISHED{Rocha2009,
  author = {Rodrigo G. C. Rocha, Alan Kelon de O. Moraes, Silvio Lemos Meira},
  title = {Fatores que Afetam o Desenvolvimento Distribuído de Software},
  note = {É apenas uma proposta de revisão sistemática publicado em:
	
	ROCHA, R. G. C. ; MORAES, A. K. O. ; Meira, S. R. L. . Fatores que
	Afetam o Desenvolvimento Distribuído de Software. In: VII Workshop
	de Teses e Dissertações em Qualidade de Software (WTDQS 2009), 2009,
	Ouro Preto-MG. VIII Simpósio Brasileiro de Qualidade de Software
	- VII Workshop de Teses e Dissertações em Qualidade de Software,
	2009. p. 7-12.},
  year = {2009},
  owner = {david},
  timestamp = {2010.02.10}
}

@ARTICLE{Schmidt:2006:ieeecomputer,
  author = {Schmidt, Douglas C.},
  title = {Guest Editor's Introduction: Model-Driven Engineering},
  journal = {IEEE Computer},
  year = {2006},
  volume = {39},
  pages = {25--31},
  number = {2}
}

@ARTICLE{Selic2003,
  author = {Selic, Bran},
  title = {The Pragmatics of Model-Driven Development},
  journal = {IEEE Softw.},
  year = {2003},
  volume = {20},
  pages = {19--25},
  number = {5},
  address = {Los Alamitos, CA, USA},
  doi = {http://dx.doi.org/10.1109/MS.2003.1231146},
  issn = {0740-7459},
  publisher = {IEEE Computer Society Press},
  review = {MDD’s defining characteristic is that software development’s primary
	focus and products are models rather than computer programs. The
	major advantage of this is that we express models using concepts
	that are much less bound to the underlying implementation technology
	and are much closer to the problem domain relative to most popular
	programming languages. This makes the models easier to specify, understand,
	and maintain; in some cases, it might even be possible for domain
	experts rather than computing technology specialists to produce systems.
	
	
	
	
	O que caracteriza o MDD é que o foco primário do desenvolvimento de
	software são os modelos ao invés dos programas de computador. A principal
	vantagem disse é que pode-se expressar modelos usando conceitos menos
	vinculados a detalhes de implementação e são muito mais próximos
	do domínio do problema. Isto torna os modelos mais fáceis de se especificar,
	entender e manter; em alguns casos, ainda pode ser possível os especialistas
	do domínio produzirem sistemas ao invés dos especialistas de uma
	tecnologia de implementação \cite{Selic2003}},
  timestamp = {2010.02.04}
}

@ARTICLE{Sherif:2006:ijim,
  author = {Sherif, Karma and Appan, Radha and Lin, Zhangxi},
  title = {{Resources and incentives for the adoption of systematic software
	reuse}},
  journal = {International Journal of Information Management},
  year = {2006},
  volume = {26},
  pages = {70--80},
  number = {1}
}

@INPROCEEDINGS{Souza1999,
  author = {Souza, C.R.B. and Santos, D.B. and Wainer, J. and Dias, K.L.},
  title = {A model and tool for semi-automatic recording of design rationale
	in software diagrams},
  booktitle = {String Processing and Information Retrieval Symposium, 1999 and International
	Workshop on Groupware},
  year = {1999},
  pages = {306-313},
  abstract = {The purpose of this work is to present an annotation model for recording
	design rationale, and to describe ABCDE-DR, a prototype system which
	implements this model, in particular for the domain of object diagrams
	in software engineering. It supports: semi-formal representation
	of DR; recording of design rationale in a semiautomatic manner through
	the reflection in action theory; and the integration between artifact
	and design rationale. Our model uses annotations as a means of cooperations
	among users and also representing design rationale information},
  doi = {10.1109/SPIRE.1999.796608},
  keywords = {diagrams, groupware, software engineeringABCDE-DR, action theory,
	annotation model, cooperative software design, design rationale,
	object diagrams, prototype system, semi-automatic recording, software
	diagrams, software engineering},
  review = {Fala muito das vantagens do DR},
  theme = {DR},
  timestamp = {2010.02.02}
}

@INPROCEEDINGS{Sriplakich2006,
  author = {Sriplakich, P. and Blanc, X. and Gervais, M.-P.},
  title = {Supporting Collaborative Development in an Open MDA Environment},
  booktitle = {Software Maintenance, 2006. ICSM '06. 22nd IEEE International Conference
	on},
  year = {2006},
  pages = {244-253},
  month = {September},
  abstract = {The MDA approach aims to ease software maintenance faced with platform
	and business evolution. In this approach, main development artifacts,
	i.e. models, are defined with the meta object facility (MOF) standard.
	To support collaborative development in MDA, we propose a mechanism
	for merging concurrent changes to MOF models. Our approach has the
	following novel functionality. First, as MOF models can have ordered
	relations, our mechanism can identify the order changes in MOF models,
	detect the conflicts caused by concurrent order changes, and integrate
	those changes. Second, as MOF models must respect multiplicity constraints,
	our mechanism detects the concurrent modifications that result in
	multiplicity violations. Therefore, it ensures the consistency of
	the merge result. Third, we offer a framework for building conflict
	resolution programs dedicated to developers' particular requirements.
	This framework offers a flexible and automated way for resolving
	conflicts. This work is a part of ModelBus, an open environment for
	CASE tool interoperability. Its contribution is to enable models
	to be concurrently modified by several developers and with different
	tools. ModelBus implementation is available as the Eclipse open source
	project, model driven development integration (MDDi)},
  doi = {10.1109/ICSM.2006.64},
  file = {:C\:\\Documents and Settings\\david\\Meus documentos\\My Dropbox\\PROJETO DE MESTRADO\\Artigos\\Supporting Collaborative Development in an Open MDA Environment - Sriplakich2006.pdf:PDF},
  issn = {1063-6773},
  keywords = {computer aided software engineering, configuration management, formal
	specification, public domain software, software maintenanceCASE tool
	interoperability, Eclipse open source project, ModelBus, business
	evolution, collaborative development, conflict resolution program,
	meta object facility standard, model driven development integration,
	multiplicity constraint, open MDA environment, software configuration
	management, software maintenance},
  review = {O artigo propõe um mecanismo para mesclar modificações concorrentes
	em modelos MOF para dar suporte ao desenvolvimento colaborativo em
	MDA.
	
	Este trabalho é parte do ModelBus, um ambiente aberto ...
	
	Fala da importância do desenvolvimento colaborativo e da abordagem
	copy-modify-merge que suporta colaboração, a qual será usada como
	uma abordagem de desenvolvimento de modelos .
	
	A idéia é propor um mecanismo que consiga a partir de um modelo base
	e de um modelo modificado, extrair as modificações entre eles.
	
	O autor destaca alguns problemas de inserir os modelos modificados
	no repositório, como perda de alterações e inconsistência de dados.
	
	Ao longo do texto, o autor mostra um mecanismo que extrai modificações
	de modelos mesclados, focando no problema de inconsistência de modelos.Este
	mecanismo é aplicado no ModelBus, uma plataforma para interoperabilidade
	de ferramentas CASE. O ModelBus permite que diversos desenvolvedores
	usem diferentes ferramentas CASE para realizar um desenvolvimento
	colaborativo, ou seja "... eles podem concorrentemente usar diferentes
	ferramentas para atualizar os modelos compartilhados" \cite{Sriplakich}.
	
	A arquitetura do ModelBus para dar suporte ao desenvolvimento colaborativo
	é composta de um repositório, de um "merging framework" e de um gerenciamento
	de nós IDs. O repositório usa as funcionalidades básicas de repositórios
	gerenciadores de configuração de software (Software Configuration
	Management - SCM), como o CVS (Concurrent Version System) ou o Subversion,
	para armazenar os modelos que sao compartilhados peloas diversas
	ferramentas e para manter a trajetória no histórico das modificações
	dos modelos.
	
	O "merging framework" é um componente que contém a implementação do
	mecanismo de mesclagem de modelos.
	
	Conclusão:
	
	
	
	No MDD, modelos são os artefatos de desenvolvimento principal, que
	são usados para descrever vários aspectos de software e para automatizar
	a geração de código. Eles não são usados apenas para produzir um
	novo software, mas também para manter um já existente \cite{Sriplakich2006}.},
  theme = {SCM, Merge},
  timestamp = {2010.01.24}
}

@BOOK{Stahl2006,
  title = {Model-Driven Software Development: Technology, Engineering, Management},
  publisher = {John Wiley \& Sons},
  year = {2006},
  editor = {Whiley},
  author = {Stahl, Thomas and Voelter, Markus and Czarnecki, Krzysztof},
  isbn = {0470025700},
  timestamp = {2010.02.04}
}

@INPROCEEDINGS{steffen:2007,
  author = {Steffen, Bernhard and Margaria, Tiziana and Nagel, Ralf and Jörges,
	Sven and Kubczak, Christian},
  title = {{Model-Driven Development with the jABC }},
  booktitle = {Hardware and Software, Verification and Testing (available at http://www.springerlink.com/content/30v87502kn5h6672)},
  year = {2007},
  pages = {92--108},
  address = {Berlin / Heidelberg},
  publisher = {Springer-Verlag LNCS - DOI - 10.1007/978-3-540-70889}
}

@ARTICLE{Sanchez2009,
  author = {Pablo Sánchez and Ana Moreira and Lidia Fuentes and João Araújo and
	José Magno},
  title = {Model-driven development for early aspects},
  journal = {Information and Software Technology},
  year = {2009},
  volume = {In Press, Corrected Proof},
  pages = { - },
  doi = {DOI: 10.1016/j.infsof.2009.09.001},
  issn = {0950-5849},
  keywords = {Early aspects},
  timestamp = {2010.02.04},
  url = {http://www.sciencedirect.com/science/article/B6V0B-4XMD5H4-1/2/6ea38b8dfd8b3a555a3eacba8e25f226}
}

@CONFERENCE{Teppola2009,
  author = {Teppola, S. and Parviainen, P. and Takalo, J.},
  title = {Challenges in the deployment of model driven development},
  booktitle = {4th International Conference on Software Engineering Advances, ICSEA
	2009},
  year = {2009},
  pages = {15-20},
  address = {Porto},
  note = {cited By (since 1996) 0; Conference of 4th International Conference
	on Software Engineering Advances, ICSEA 2009, Includes SEDES 2009:
	Simposio para Estudantes de Doutoramento em Engenharia de Software;
	Conference Date: 20 September 2009 through 25 September 2009; Conference
	Code: 78651},
  abbrev_source_title = {Int. Conf. Softw. Eng. Adv., ICSEA, Incl. SEDES: Simp. Estud. Doutoramento
	Eng. Softw.},
  abstract = {Model-driven development (MDD) is an approach that focuses on creating
	models as first class development artifacts to produce source code
	by utilizing model transformations. Process support is needed for
	effective MDD as it guides the development of the model and helps
	to manage the relationships between models. Our paper highlights
	the results of the survey on real life experiences of using MDD in
	companies. The results confirm the validity of the previously published
	MDD-related challenges. Regardless of the advantages identified by
	the respondents there are still many challenges to tackle before
	MDD will become more generally used in organizations. However, respondents
	found the approach useful and state that in the next five years the
	product development processes, methods and tools will be developed
	towards MDD adoption in their organizations. Â© 2009 IEEE.},
  affiliation = {Technical Research Centre of Finland, VTT, Oulu, 90571, Finland},
  art_number = {5298434},
  author_keywords = {Development process support; Model driven development},
  correspondence_address = {Teppola, S.; Technical Research Centre of Finland, VTT, Oulu, 90571,
	Finland; email: susanna.teppola@vtt.fi},
  document_type = {Conference Paper},
  doi = {10.1109/ICSEA.2009.11},
  isbn = {9780769537771},
  journal = {4th International Conference on Software Engineering Advances, ICSEA
	2009, Includes SEDES 2009: Simposio para Estudantes de Doutoramento
	em Engenharia de Software},
  keywords = {Development process; Model driven development; Model transformation;
	Process support; Product development process; Source codes, Product
	development, Computer software},
  language = {English},
  review = {Model-driven development (MDD) is an approach
	
	that focuses on creating models as first class development
	
	artifacts to produce source code by utilizing model
	
	transformations.},
  source = {Scopus},
  sponsors = {IARIA},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-70749142163&partnerID=40&md5=f5eaa00c628066e43c6ef182e23fdd87}
}

@INPROCEEDINGS{Tetard2009,
  author = {Franck Tetard and Erkki Patokorpi and Kristian Packalen},
  title = {Using Wikis to Support Constructivist Learning: A Case Study in University
	Education Settings},
  booktitle = {HICSS '09: Proceedings of the 42nd Hawaii International Conference
	on System Sciences},
  year = {2009},
  pages = {1--10},
  address = {Washington, DC, USA},
  month = {Jan},
  publisher = {IEEE Computer Society},
  abstract = {According to Tim Berners-Lee, wiki technology represents an instantiation
	of how the World Wide Web was planned to work: a platform that users
	can use both to retrieve content (read) and contribute content (write).
	Wiki technology lends itself to many uses. One of the main features
	of wiki technology is its support for collaborative editing of content.
	In this paper, we introduce briefly wiki technology, the pedagogical
	premises of the use of wiki in education, and present one case of
	the use of wiki in university education context as support for constructivist
	collaborative learning. We present empirical data on the participants'
	evaluation of the use of wiki, and the analysis by the course instructor.
	We also discuss possibilities and potential problem situations when
	utilizing wiki-technology in educational settings, in particular
	related to the assessment of learning, the monitoring of student
	participation, and the need for communication support in the learning
	process.},
  doi = {http://dx.doi.org/10.1109/HICSS.2009.499},
  isbn = {978-0-7695-3450-3},
  keywords = {Internet, computer aided instruction, content-based retrieval, educational
	courses, groupwareWorld Wide Web, constructivist collaborative learning,
	content based retrieval, course instructor, university education
	setting, wiki technology},
  timestamp = {2010.02.16}
}

@INPROCEEDINGS{Tichy1982,
  author = {Tichy, Walter F.},
  title = {Design, implementation, and evaluation of a Revision Control System},
  booktitle = {ICSE '82: Proceedings of the 6th international conference on Software
	engineering},
  year = {1982},
  pages = {58--67},
  address = {Los Alamitos, CA, USA},
  publisher = {IEEE Computer Society Press},
  file = {:home/david/Dropbox/PROJETO DE MESTRADO/Artigos/Design, implementation, and evaluation of a Revision Control System - Tichy1982.pdf:PDF},
  location = {Tokyo, Japan},
  problem/context = {crossref: Dissertação do Junqueira},
  review = {The Revision Control System (RCS) is a software tool that helps in
	managing multiple 
	
	revisions of text. RCS automates the storing, retrieval, logging,
	identification, and merging
	
	of revisions, and provides access control. It is useful for text that
	is revised frequently, for
	
	example programs and documentation.
	
	
	Um sistema de controle de versão ou ..., é uma ferramenta que ajuda
	no gerenciamento de múltiplas revisões do texto. Este sistema automatiza
	o armazenamento, recuperação, registro, identificação e \textit{merge}
	das revisões e fornece controle de acesso.É útil para textos que
	são revisados com freqüência, como por exemplo programas e documentação},
  timestamp = {2010.02.02},
  url = {http://portal.acm.org/citation.cfm?id=807748#}
}

@BOOKLET{Truyen2006,
  title = {The Fast Guide to Model Driven Architecture, The Basics of Model
	Driven Architecture},
  author = {Frank Truyen},
  month = {January},
  year = {2006},
  owner = {david},
  timestamp = {2010.02.04}
}

@ARTICLE{Walz1993,
  author = {Diane B. Walz and Joyce J. Elam and Bill Curtis},
  title = {Inside a Software Design Team: Knowledge Acquisition, Sharing, and
	Integration},
  journal = {Commun. ACM},
  year = {1993},
  volume = {36},
  pages = {63--77},
  number = {10},
  month = {October},
  address = {New York, NY, USA},
  citeulike-article-id = {2880258},
  citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=163447},
  citeulike-linkout-1 = {http://dx.doi.org/10.1145/163430.163447},
  doi = {10.1145/163430.163447},
  issn = {0001-0782},
  keywords = {case\_studies, design, teams, teamwork},
  posted-at = {2008-06-10 17:31:36},
  priority = {4},
  publisher = {ACM},
  refenciado = {Lanubile2009},
  relevance = {5},
  review = {Parece ser muito interessante pois fala},
  timestamp = {2010.02.10},
  url = {http://dx.doi.org/10.1145/163430.163447}
}

@ARTICLE{Warmer2007,
  author = {Warmer, J.},
  title = {A Model Driven Software Factory Using Domain Specific Languages},
  journal = {Lecture Notes in Computer Science (including subseries Lecture Notes
	in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year = {2007},
  volume = {4530 LNCS},
  pages = {194-203},
  note = {cited By (since 1996) 1; Conference of 3rd European Conference on
	Model-Driven Architecture - Foundations and Applications, ECMDA-FA
	2007; Conference Date: 11 June 2007 through 15 June 2007; Conference
	Code: 70752},
  abbrev_source_title = {Lect. Notes Comput. Sci.},
  abstract = {This paper describes the development of the SMART-Microsoft Software
	Factory. This factory is a fully model driven factory that makes
	extensive use of the Microsoft DSL Tools and is bases on the Microsoft
	Service Oriented Architecture. We describe the process used for developing
	the factory and share the experience gained in the first projects
	in which this factory has been used. The first project has 73% of
	the delivered code being generated. Â© Springer-Verlag Berlin Heidelberg
	2007.},
  address = {Haifa},
  correspondence_address = {Warmer, J., Ordina, Netherlands; email: jos.warmer@ordina.nl},
  document_type = {Conference Paper},
  isbn = {3540729003; 9783540729006},
  issn = {03029743},
  keywords = {Computer architecture; Domain decomposition methods; Model checking;
	Problem solving; Project management, Domain specific languages; Microsoft
	Service Oriented Architecture; Model driven software factory, Software
	engineering},
  language = {English},
  source = {Scopus},
  timestamp = {2010.02.17},
  url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-37149003724&partnerID=40&md5=9f3792b3ac1fa84bd4889ab6406d051e}
}

@INPROCEEDINGS{Wenzel2008,
  author = {Wenzel, Sven},
  title = {Scalable visualization of model differences},
  booktitle = {CVSM '08: Proceedings of the 2008 international workshop on Comparison
	and versioning of software models},
  year = {2008},
  pages = {41--46},
  address = {New York, NY, USA},
  publisher = {ACM},
  abstract = {If large models are compared their difference can contain a huge number
	of local changes. Conventional methods for displaying differences
	cannot reasonably handle such large differences. This paper proposes
	a solution to this problem. Our approach is based on the concept
	of polymetric views and extends it in two ways: firstly, we propose
	metrics for differences which quantify properties of differences
	and distinguish relevant from irrelevant changes. Moreover, we propose
	new graphical features of polymetric views. This combination provides
	a scalable presentation of differences which makes the changes of
	large models comprehensible.},
  doi = {http://doi.acm.org/10.1145/1370152.1370163},
  file = {:C\:\\Documents and Settings\\david\\Meus documentos\\My Dropbox\\PROJETO DE MESTRADO\\Artigos\\Scalable Visualization of Model Differences - Wenzel2008.pdf:PDF},
  isbn = {978-1-60558-045-6},
  keywords = {difference computation, metrics, model-driven development},
  location = {Leipzig, Germany},
  refenciado = {Bendix2009},
  situation = {Stand by},
  theme = {Comparação de Modelos},
  timestamp = {2010.01.22}
}

@INPROCEEDINGS{Xing2005,
  author = {Xing, Zhenchang and Stroulia, Eleni},
  title = {UMLDiff: an algorithm for object-oriented design differencing},
  booktitle = {ASE '05: Proceedings of the 20th IEEE/ACM international Conference
	on Automated software engineering},
  year = {2005},
  pages = {54--65},
  address = {New York, NY, USA},
  publisher = {ACM},
  abstract = {This paper presents UMLDiff, an algorithm for automatically detecting
	structural changes between the designs of subsequent versions of
	object-oriented software. It takes as input two class models of a
	Java software system, reverse engineered from two corresponding code
	versions. It produces as output a change tree, i.e., a tree of structural
	changes, that reports the differences between the two design versions
	in terms of (a) additions, removals, moves, renamings of packages,
	classes, interfaces, fields and methods, (b) changes to their attributes,
	and (c) changes of the dependencies among these entities. UMLDiff
	produces an accurate report of the design evolution of the software
	system, and enables subsequent design-evolution analyses from multiple
	perspectives in support of various evolution activities. UMLDiff
	and the analyses it enables can assist software engineers in their
	tasks of understanding the rationale of design evolution of the software
	system and planning future development and maintenance activities.
	We evaluate UMLDiff's correctness and robustness through a real-world
	case stud.},
  citeulike-article-id = {1586336},
  citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1101919},
  citeulike-linkout-1 = {http://dx.doi.org/10.1145/1101908.1101919},
  doi = {10.1145/1101908.1101919},
  isbn = {1-59593-993-4},
  keywords = {mdd, transformation},
  location = {Long Beach, CA, USA},
  posted-at = {2007-08-23 17:18:52},
  priority = {0},
  timestamp = {2010.02.17},
  url = {http://dx.doi.org/10.1145/1101908.1101919}
}

@OTHER{Zimmerly2009,
  author = {Bill Zimmerly},
  month = {April},
  organization = {IBM},
  owner = {david},
  review = {WCMS:
	
	Core features
	
	Let's now review the core features of a general-purpose CMS.
	
	- Create and manage content sections or hierarchy
	
	- Create pages and easily add text or image content
	
	- Rearrange or edit published content at any time
	
	- Automatic linking and content publishing
	
	- Allow multiple users to administer or manage content
	
	
	Wiki CMS:
	
	Wikis are used both in private and public networks, and can be customized
	to suit your
	
	needs. Here are some core features:
	
	- Easily create and edit pages just with a browser
	
	- Simple formatting markup syntax
	
	- Automatic/simple link creation, even if the target page does not
	exist (yet)
	
	- Invites visitors to contribute
	
	- Complete revision history—roll back at any time
	
	- Can restrict editing by logged in user or group of users
	
	Wikis are collaborative by nature. The quality of content improves
	as people contribute.
	
	
	Collaboration CMSs
	
	A collaboration CMS is generally designed for internal users of an
	organization. Users could
	
	be all employees, partners, or customers. The needs of every organization
	may be different,
	
	and an Intranet may have variety of systems—from HR to groupware to
	ERP.
	
	Core features
	
	The following are the core features you can expect from a collaboration
	CMS:
	
	- User management
	
	- Document/Records Management—assets, revisions, comments
	
	- Workflow and approval processes
	
	- Groups/Spaces to organize work
	
	- Blog, forum, Wiki, and so on for collaboration
	
	- Desktop access, APIs, and standard compliance for integration with
	other systems
	
	- System-specific features—contact management, knowledge base, project
	management, and so on
	
	
	A wise choice would be to take an open source Intranet CMS and customize
	it to your needs.
	
	
	Possible uses
	
	Intranets can significantly reduce email, or communication, overload
	and speed up
	
	processes. They also help to keep most of the information in a single
	place. Here are some
	
	possible uses of Intranets. They:
	
	- Keep all your policies, forms, and documents in one place
	
	- Use workflows to manage design or documentation approvals
	
	- Manage changes to documents through revision control
	
	- Build third-party integration and hook up to a payroll or project
	management system
	
	- Manage marketing campaigns by centralizing all information, documents,
	media assets, and reports
	
	Set up a knowledge base using a Wiki or document management
	
	
	
	Different types, but strong overlap
	
	We looked at the different types of CMSs, from general-purpose to
	photo galleries. Each had its own core feature set, but all the CMSs
	have a strong overlap of functionality. They all essentially allow
	you to add and manage some type of content—text, images, and files.
	The way content displays to the end user may be different, but a
	lot of internals are the same. Here are some of the features you
	will see in many CMSs:
	
	- WYSIWYG Editor: A What You See Is What You Get editor allows you
	to enter text and format it. Most such editors even allow you to
	add images and other media.
	
	- Categories and content hierarchy: Sections, categories or nested
	levels to organize content are very common.
	
	- Search Engine Optimization: Search engine friendly URLs, meta tags
	are supported.
	
	- Tagging: Tag content with keywords, then display a "tag cloud" or
	list.
	
	- Different User Levels: Most CMSs allow multiple users to manage
	content. Many even have roles and access levels to control what each
	user can do.
	
	- Plug-in Support: Extend core features by adding plug-ins and extensions.
	
	- Themes/Skins: Customize the look and feel with themes.
	
	- Comments, and so on: Comments and other social media, or Web 2.0
	features, are widely available.
	
	
	Technically, you can use any CMS, such as Joomla!, Drupal, WordPress,
	DotNetNuke, as an internal CMS. You can very well use them on your
	intranet. The value of an internal CMS will be determined by the
	content you add.
	
	At the same time, there are a few enterprise CMSs that can elevate
	your team's productivity by making it easier to collaborate and communicate.
	A team collaboration CMS should make it easy to share documents and
	collaborate with other team members. It should manage content revisions,
	have some kind of workflow system, and provide additional tools for
	better system integration. Such features are generally not available
	in typical Web CMSs. That is the reason why we need to look specifically
	at team collaboration CMSs.
	
	
	What makes Wikis special?
	
	It's not only the ease of contribution that makes Wikis special. The
	following are some highlights:
	
	- Effortlessly create links and content; create links even without
	content
	
	- Full access control—users and pages
	
	- Many Wikis don't even need a database backend, which makes them
	portable
	
	- Revision control—review changes and roll back
	
	- You can even categorize pages for better organization
	
	- Top Wikis also have keyboard controls—for example, press Ctrl+S
	to save
	
	- Automatic Table of Contents creation
	
	- Extensive search capabilities},
  timestamp = {2010.02.11},
  title = {Entendendo o Software wiki},
  url = {http://www.ibm.com/developerworks/br/library/os-social-mediawiki/index.html},
  year = {2009}
}

@PROCEEDINGS{NW-MODE2009,
  title = {SPLST’09 \& NW-MODE’09: Proceedings of 11th Symposium on Programming
	Languages and Software Tools and 7th Nordic Workshop on Model Driven
	Software Engineering},
  year = {2009},
  file = {:C\:\\Documents and Settings\\david\\Meus documentos\\My Dropbox\\PROJETO DE MESTRADO\\Artigos\\Proceedings of SPLST09 and NWMODE09.pdf:PDF},
  owner = {david},
  situation = {Stand by},
  timestamp = {2010.01.22}
}

@PROCEEDINGS{CVSM2008,
  title = {CVSM '08: Proceedings of the 2008 international workshop on Comparison
	and versioning of software models},
  year = {2008},
  address = {New York, NY, USA},
  publisher = {ACM},
  note = {Program Chair-Ebert, J\"{u}rgen and Program Chair-Kelter, Udo and
	Program Chair-Syst\"{a}, Tarja},
  abstract = {Modern software development approaches, especially those which follow
	a model-driven way of development, make heavy use of models during
	the whole development process. In this context models are being evolved,
	simplified and/or extended, over a longer period of time. This kind
	of model evolution leads to the need of keeping different versions
	of models, of comparing them, of measuring their (un)similarity,
	and of merging different models into one.
	
	
	Conventional techniques for document comparison, document retrieval,
	and document reuse, which have been developed in the context of version
	and configuration management systems, are primarily aimed at textual
	documents. They make use of a large body of knowledge developed over
	the years in the context of version management systems. They are
	not directly applicable to models, especially if they come as visual
	documents like UML diagrams. For models written in visual languages
	the foundations, algorithms, and tools are not so elaborated yet.
	
	
	The aim of the ICSE 2008 workshop on Comparison and Versioning of
	Software Models (CVSM08) is to establish the state of the art in
	the area of comparing and versioning of models. It follows similar
	events at the German Software Engineering Conference (SE 2007) in
	March 2007 in Hamburg, Germany (http://pi.informatik.uni-siegen.de/gi/fg211/VVUM07/),
	and at the Nordic Workshop on Model Driven Software Engineering (NW-MoDE'07)
	in June 2007 in Ronneby, Sweden (http://www.ituniv.se/~miroslaw/node.htm).
	
	
	14 contributions were submitted in response to the call. Each paper
	was assessed by at least three members of the program committee who
	agreed to accept 8 papers for this workshop. These papers hopefully
	will raise fruitful and inspiring discussions during the meeting.
	They will be presented in three sessions which are planned to provide
	enough time for extensive discussions. The final session will be
	dedicated to the discussion of a road map for future research in
	this area.},
  isbn = {978-1-60558-045-6},
  location = {Leipzig, Germany},
  order_no = {529080},
  refenciado = {Bartelt2008, Kogel2008, Murta2008, Wenzel2008},
  review = {Ver table of contents em: http://portal.acm.org/toc.cfm?id=1370152&type=proceeding&coll=GUIDE&dl=GUIDE&CFID=72442566&CFTOKEN=68041856
	
	
	Table of Contents
	
	
	SESSION: Model comparison
	
	 Comparing state machines 
	
	Udo Kelter, Maik Schmidt 
	
	Pages 1-6 
	
	Full text available: Pdf(287 KB)
	
	Additional Information:full citation, abstract, references, index
	terms
	
	 Matching class diagrams: with estimated costs towards the exact solution?
	
	
	Sabrina Uhrig 
	
	Pages 7-12 
	
	Full text available: Pdf(237 KB)
	
	Additional Information:full citation, abstract, references, index
	terms
	
	
	
	SESSION: Configuration management and model merging
	
	 Consistence preserving model merge in collaborative development processes
	
	
	Christian Bartelt 
	
	Pages 13-18 
	
	Full text available: Pdf(409 KB)
	
	Additional Information:full citation, abstract, references, index
	terms
	
	 Towards software configuration management for unified models
	
	
	Maximilian Kögel 
	
	Pages 19-24 
	
	Full text available: Pdf(272 KB)
	
	Additional Information:full citation, abstract, references, index
	terms
	
	 Towards odyssey-VCS 2: improvements over a UML-based version control
	system 
	
	Leonardo Murta, Chessman Corrêa, João Gustavo Prudêncio, Cláudia Werner
	
	
	Pages 25-30 
	
	Full text available: Pdf(253 KB)
	
	Additional Information:full citation, abstract, references, index
	terms
	
	
	
	SESSION: Applications
	
	 Diff and merge support for model based development 
	
	Lars Bendix, Pär Emanuelsson 
	
	Pages 31-34 
	
	Full text available: Pdf(208 KB)
	
	Additional Information:full citation, abstract, references, index
	terms
	
	 Using model comparison to maintain model-to-standard compliance
	
	
	Martín Soto, Jürgen Münch 
	
	Pages 35-40 
	
	Full text available: Pdf(373 KB)
	
	Additional Information:full citation, abstract, references, index
	terms
	
	 Scalable visualization of model differences 
	
	Sven Wenzel 
	
	Pages 41-46 
	
	Full text available: Pdf(285 KB)
	
	Additional Information:full citation, abstract, references, cited
	by, index terms},
  situation = {Stand by},
  theme = {Comparação e Versionamento},
  timestamp = {2010.01.22},
  url = {http://portal.acm.org/citation.cfm?id=1370152&coll=GUIDE&dl=GUIDE&CFID=72442566&CFTOKEN=68041856#}
}

@comment{jabref-meta: selector_publisher:}

@comment{jabref-meta: selector_author:}

@comment{jabref-meta: selector_journal:}

@comment{jabref-meta: selector_keywords:}

